import { baseLogger, chalk, AuthenticationError, AuthorizationError, isPast, CSRFTokenMismatchError, differenceInMinutes, assert, addMinutes, addYears, log, createServerPlugin } from 'blitz';
import { toBase64, fromBase64 } from 'b64-lite';
import cookie, { parse } from 'cookie';
import jsonwebtoken from 'jsonwebtoken';
import { o as HEADER_CSRF, s as HEADER_CSRF_ERROR, q as HEADER_PUBLIC_DATA_TOKEN, r as HEADER_SESSION_CREATED, m as COOKIE_CSRF_TOKEN, w as formatWithValidation, C as COOKIE_ANONYMOUS_SESSION_TOKEN, k as COOKIE_SESSION_TOKEN, l as COOKIE_REFRESH_TOKEN, j as SESSION_TOKEN_VERSION_0, H as HANDLE_SEPARATOR, S as SESSION_TYPE_OPAQUE_TOKEN_SIMPLE, i as SESSION_TYPE_ANONYMOUS_JWT, T as TOKEN_SEPARATOR, n as COOKIE_PUBLIC_DATA_TOKEN } from './index.mjs';
import * as crypto from 'crypto';
import { nanoid } from 'nanoid';
import _debug from 'debug';

const hash256 = (input = "") => {
  return crypto.createHash("sha256").update(input).digest("hex");
};
const generateToken = (numberOfCharacters = 32) => nanoid(numberOfCharacters);

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function splitCookiesString(cookiesString) {
  if (!cookiesString)
    return [];
  let cookiesStrings = [];
  let pos = 0;
  let start;
  let ch;
  let lastComma;
  let nextStart;
  let cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          cookiesSeparatorFound = true;
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
function isLocalhost(req) {
  let host;
  if (req instanceof Request) {
    host = req.headers.get("host") || "";
  } else {
    host = req.headers.host || "";
  }
  let localhost = false;
  if (host) {
    host = host.split(":")[0];
    localhost = host === "localhost";
  }
  return localhost;
}
function getCookieParser(headers) {
  return function parseCookie() {
    const header = headers.cookie;
    if (!header) {
      return {};
    }
    return parse(Array.isArray(header) ? header.join(";") : header);
  };
}
const debug = _debug("blitz:session");
const simpleRolesIsAuthorized = ({ ctx, args }) => {
  const [roleOrRoles] = args;
  const publicData = ctx.session.$publicData;
  if ("role" in publicData && "roles" in publicData) {
    throw new Error("Session publicData can only have only `role` or `roles`, but not both.'");
  }
  let roles = [];
  if ("role" in publicData) {
    if (typeof publicData.role !== "string") {
      throw new Error("Session publicData.role field must be a string");
    }
    roles.push(publicData.role);
  } else if ("roles" in publicData) {
    if (!Array.isArray(publicData.roles)) {
      throw new Error("Session `publicData.roles` is not an array, but it must be");
    }
    roles = publicData.roles;
  } else {
    throw new Error("Session publicData is missing the required `role` or roles` field");
  }
  if (!roleOrRoles)
    return true;
  const rolesToAuthorize = [];
  if (Array.isArray(roleOrRoles)) {
    rolesToAuthorize.push(...roleOrRoles);
  } else if (roleOrRoles) {
    rolesToAuthorize.push(roleOrRoles);
  }
  for (const role of rolesToAuthorize) {
    if (roles.includes(role))
      return true;
  }
  return false;
};
function ensureMiddlewareResponse(res) {
  if (!("blitzCtx" in res)) {
    res.blitzCtx = {};
  }
}
function convertRequestToHeader(req) {
  const headersFromRequest = req.headers;
  if (headersFromRequest instanceof Headers) {
    return headersFromRequest;
  } else {
    const headers = new Headers();
    Object.entries(headersFromRequest).forEach(([key, value]) => {
      if (value) {
        if (Array.isArray(value)) {
          headers.append(key, value.join(","));
        } else {
          headers.append(key, value);
        }
      }
    });
    return headers;
  }
}
function getCookiesFromHeader(headers) {
  const cookieHeader = headers.get("Cookie");
  if (cookieHeader) {
    return cookie.parse(cookieHeader);
  } else {
    return {};
  }
}
function getSession(req, res, isRsc) {
  return __async$1(this, null, function* () {
    const headers = convertRequestToHeader(req);
    if (res) {
      ensureMiddlewareResponse(res);
      debug("cookiePrefix", globalThis.__BLITZ_SESSION_COOKIE_PREFIX);
      if (res.blitzCtx.session) {
        debug("Returning existing session");
        return res.blitzCtx.session;
      }
    }
    const method = req.method;
    let sessionKernel = yield getSessionKernel({ headers, method });
    if (sessionKernel) {
      debug("Got existing session", sessionKernel);
    }
    if (!sessionKernel) {
      sessionKernel = yield createAnonymousSession({ headers });
    }
    const sessionContext = makeProxyToPublicData(
      new SessionContextClass(headers, sessionKernel, !!isRsc, res)
    );
    debug("New session context");
    if (res) {
      res.blitzCtx = {
        session: sessionContext
      };
      sessionContext.setSession(res);
    }
    return sessionContext;
  });
}
const makeProxyToPublicData = (ctxClass) => {
  return new Proxy(ctxClass, {
    get(target, prop, receiver) {
      if (prop in target || prop === "then") {
        return Reflect.get(target, prop, receiver);
      } else {
        return Reflect.get(target.$publicData, prop, receiver);
      }
    }
  });
};
function getBlitzContext() {
  return __async$1(this, null, function* () {
    try {
      const { headers, cookies } = require("next/headers");
      const reqHeader = Object.fromEntries(headers());
      const csrfToken = cookies().get(COOKIE_CSRF_TOKEN());
      if (csrfToken) {
        reqHeader[HEADER_CSRF] = csrfToken.value;
      }
      const session = yield getSession(
        {
          headers: new Headers(reqHeader),
          method: "POST"
        },
        null,
        true
      );
      const ctx = {
        session
      };
      return ctx;
    } catch (e) {
      if (e.code === "MODULE_NOT_FOUND") {
        throw new Error(
          "Usage of `getBlitzContext` is supported only in next.js 13.0.0 and above. Please upgrade your next.js version."
        );
      }
      throw e;
    }
  });
}
function useAuthenticatedBlitzContext(_0) {
  return __async$1(this, arguments, function* ({
    redirectTo,
    redirectAuthenticatedTo,
    role
  }) {
    const log2 = baseLogger().getSubLogger({ name: "useAuthenticatedBlitzContext" });
    const customChalk = new chalk.Instance({
      level: log2.settings.type === "json" ? 0 : chalk.level
    });
    const ctx = yield getBlitzContext();
    const userId = ctx.session.userId;
    try {
      const { redirect } = require("next/navigation");
      if (userId) {
        debug("[useAuthenticatedBlitzContext] User is authenticated");
        if (redirectAuthenticatedTo) {
          if (typeof redirectAuthenticatedTo === "function") {
            redirectAuthenticatedTo = redirectAuthenticatedTo(ctx);
          }
          const redirectUrl = typeof redirectAuthenticatedTo === "string" ? redirectAuthenticatedTo : formatWithValidation(redirectAuthenticatedTo);
          debug("[useAuthenticatedBlitzContext] Redirecting to", redirectUrl);
          if (role) {
            try {
              ctx.session.$authorize(role);
            } catch (e) {
              log2.info("Authentication Redirect: " + customChalk.dim(`Role ${role}`), redirectTo);
              redirect(redirectUrl);
            }
          } else {
            log2.info("Authentication Redirect: " + customChalk.dim("(Authenticated)"), redirectUrl);
            redirect(redirectUrl);
          }
        }
        if (redirectTo && role) {
          debug("[useAuthenticatedBlitzContext] redirectTo and role are both defined.");
          try {
            ctx.session.$authorize(role);
          } catch (e) {
            log2.error("Authorization Error: " + e.message);
            if (typeof redirectTo !== "string") {
              redirectTo = formatWithValidation(redirectTo);
            }
            log2.info("Authorization Redirect: " + customChalk.dim(`Role ${role}`), redirectTo);
            redirect(redirectTo);
          }
        }
      } else {
        debug("[useAuthenticatedBlitzContext] User is not authenticated");
        if (redirectTo) {
          if (typeof redirectTo !== "string") {
            redirectTo = formatWithValidation(redirectTo);
          }
          log2.info("Authentication Redirect: " + customChalk.dim("(Not authenticated)"), redirectTo);
          redirect(redirectTo);
        }
      }
      return ctx;
    } catch (e) {
      if (e.code === "MODULE_NOT_FOUND") {
        throw new Error(
          "Usage of `useAuthenticatedBlitzContext` is supported only in next.js 13.0.0 and above. Please upgrade your next.js version."
        );
      }
      throw e;
    }
  });
}
const NotSupportedMessage = (method) => __async$1(void 0, null, function* () {
  const message = `Method ${method} is not yet supported in React Server Components`;
  const _box = yield log.box(message, log.chalk.hex("8a3df0").bold("Blitz Auth"));
  console.log(_box);
});
const _SessionContextClass = class {
  constructor(headers, kernel, isRsc, response) {
    this._headers = headers;
    this._kernel = kernel;
    this._isRsc = isRsc;
    this._response = response;
  }
  $antiCSRFToken() {
    return this._kernel.antiCSRFToken;
  }
  get $handle() {
    return this._kernel.handle;
  }
  get userId() {
    return this._kernel.publicData.userId;
  }
  get $publicData() {
    return this._kernel.publicData;
  }
  $authorize(...args) {
    const e = new AuthenticationError();
    Error.captureStackTrace(e, this.$authorize);
    if (!this.userId)
      throw e;
    if (!this.$isAuthorized(...args)) {
      const err = new AuthorizationError();
      Error.captureStackTrace(err, this.$authorize);
      throw err;
    }
  }
  $isAuthorized(...args) {
    if (!this.userId)
      return false;
    return global.sessionConfig.isAuthorized({
      ctx: {
        session: this
      },
      args
    });
  }
  $thisIsAuthorized(...args) {
    return this.$isAuthorized(...args);
  }
  setSession(response) {
    if (this._isRsc) {
      void NotSupportedMessage("setSession");
      return;
    }
    const cookieHeaders = this._headers.get("set-cookie");
    if (response instanceof Response) {
      response.headers.set("Set-Cookie", cookieHeaders);
    } else {
      response.setHeader("Set-Cookie", splitCookiesString(cookieHeaders));
    }
    const headers = this._headers.entries();
    for (const [key, value] of headers) {
      if (_SessionContextClass.headersToIncludeInResponse.includes(key)) {
        if (response instanceof Response) {
          response.headers.set(key, value);
        } else {
          response.setHeader(key, value);
        }
      }
    }
  }
  $create(publicData, privateData) {
    return __async$1(this, null, function* () {
      if (this._isRsc) {
        void NotSupportedMessage("$create");
        return;
      }
      this._kernel = yield createNewSession({
        headers: this._headers,
        publicData,
        privateData,
        jwtPayload: this._kernel.jwtPayload,
        anonymous: false
      });
      if (this._response)
        this.setSession(this._response);
    });
  }
  $revoke() {
    return __async$1(this, null, function* () {
      if (this._isRsc) {
        void NotSupportedMessage("$revoke");
        return;
      }
      this._kernel = yield revokeSession(this._headers, this.$handle);
      if (this._response)
        this.setSession(this._response);
    });
  }
  $revokeAll() {
    return __async$1(this, null, function* () {
      if (this._isRsc) {
        void NotSupportedMessage("$revokeAll");
        return;
      }
      yield this.$revoke();
      yield revokeAllSessionsForUser(this.$publicData.userId);
      return;
    });
  }
  $setPublicData(data) {
    return __async$1(this, null, function* () {
      if (this._isRsc) {
        void NotSupportedMessage("$setPublicData");
        return;
      }
      if (this.userId) {
        yield syncPubicDataFieldsForUserIfNeeded(this.userId, data);
      }
      this._kernel.publicData = yield setPublicData(this._headers, this._kernel, data);
      if (this._response)
        this.setSession(this._response);
    });
  }
  $getPrivateData() {
    return __async$1(this, null, function* () {
      return (yield getPrivateData(this.$handle)) || {};
    });
  }
  $setPrivateData(data) {
    return __async$1(this, null, function* () {
      if (this._isRsc) {
        void NotSupportedMessage("$setPrivateData");
        return Promise.resolve();
      }
      yield setPrivateData(this._kernel, data);
      if (this._response)
        this.setSession(this._response);
    });
  }
};
let SessionContextClass = _SessionContextClass;
SessionContextClass.headersToIncludeInResponse = [
  HEADER_CSRF,
  HEADER_CSRF_ERROR,
  HEADER_PUBLIC_DATA_TOKEN,
  HEADER_SESSION_CREATED
];
const TOKEN_LENGTH = 32;
const generateEssentialSessionHandle = () => {
  return generateToken(TOKEN_LENGTH) + HANDLE_SEPARATOR + SESSION_TYPE_OPAQUE_TOKEN_SIMPLE;
};
const generateAnonymousSessionHandle = () => {
  return generateToken(TOKEN_LENGTH) + HANDLE_SEPARATOR + SESSION_TYPE_ANONYMOUS_JWT;
};
const createSessionToken = (handle, publicData) => {
  let publicDataString;
  if (typeof publicData === "string") {
    publicDataString = publicData;
  } else {
    publicDataString = JSON.stringify(publicData);
  }
  return toBase64(
    [handle, generateToken(TOKEN_LENGTH), hash256(publicDataString), SESSION_TOKEN_VERSION_0].join(
      TOKEN_SEPARATOR
    )
  );
};
const parseSessionToken = (token) => {
  const [handle, id, hashedPublicData, version] = fromBase64(token).split(TOKEN_SEPARATOR);
  if (!handle || !id || !hashedPublicData || !version) {
    throw new AuthenticationError("Failed to parse session token");
  }
  return {
    handle,
    id,
    hashedPublicData,
    version
  };
};
const createPublicDataToken = (publicData) => {
  const payload = typeof publicData === "string" ? publicData : JSON.stringify(publicData);
  return toBase64(payload);
};
const createAntiCSRFToken = () => generateToken(TOKEN_LENGTH);
const getSessionSecretKey = () => {
  if (process.env.NODE_ENV === "production") {
    if (!process.env.SESSION_SECRET_KEY && process.env.SECRET_SESSION_KEY) {
      throw new Error(
        "You need to rename the SECRET_SESSION_KEY environment variable to SESSION_SECRET_KEY (but don't feel bad, we've all done it :)"
      );
    }
    assert(
      process.env.SESSION_SECRET_KEY,
      "You must provide the SESSION_SECRET_KEY environment variable in production. This is used to sign and verify tokens. It should be 32 chars long."
    );
    assert(
      process.env.SESSION_SECRET_KEY.length >= 32,
      "The SESSION_SECRET_KEY environment variable must be at least 32 bytes for sufficent token security"
    );
    return process.env.SESSION_SECRET_KEY;
  } else {
    return process.env.SESSION_SECRET_KEY || "default-dev-secret";
  }
};
const JWT_NAMESPACE = "blitzjs";
const JWT_ISSUER = "blitzjs";
const JWT_AUDIENCE = "blitzjs";
const JWT_ANONYMOUS_SUBJECT = "anonymous";
const JWT_ALGORITHM = "HS256";
const createAnonymousSessionToken = (payload) => {
  return jsonwebtoken.sign({ [JWT_NAMESPACE]: payload }, getSessionSecretKey() || "", {
    algorithm: JWT_ALGORITHM,
    issuer: JWT_ISSUER,
    audience: JWT_AUDIENCE,
    subject: JWT_ANONYMOUS_SUBJECT
  });
};
const parseAnonymousSessionToken = (token) => {
  const secret = getSessionSecretKey();
  try {
    const fullPayload = jsonwebtoken.verify(token, secret, {
      algorithms: [JWT_ALGORITHM],
      issuer: JWT_ISSUER,
      audience: JWT_AUDIENCE,
      subject: JWT_ANONYMOUS_SUBJECT
    });
    if (typeof fullPayload === "object") {
      return fullPayload[JWT_NAMESPACE];
    } else {
      return null;
    }
  } catch (error) {
    return null;
  }
};
const cookieOptions = (headers, expires, httpOnly) => {
  return {
    path: "/",
    secure: global.sessionConfig.secureCookies && !isLocalhost({
      headers
    }),
    sameSite: global.sessionConfig.sameSite,
    domain: global.sessionConfig.domain,
    expires: new Date(expires),
    httpOnly
  };
};
function replaceOrAppendValueInSetCookieHeader(headers, cookieName, newValue) {
  const cookies = headers.get("set-cookie");
  if (!cookies)
    return newValue;
  const cookiesAsArray = splitCookiesString(cookies);
  for (let i = 0; i < cookiesAsArray.length; i++) {
    const cookie2 = cookiesAsArray[i];
    if (cookie2 == null ? void 0 : cookie2.startsWith(cookieName)) {
      cookiesAsArray[i] = newValue;
      return cookiesAsArray.join(", ");
    } else {
      if (i === cookiesAsArray.length - 1) {
        cookiesAsArray.push(newValue);
        return cookiesAsArray.join(", ");
      }
    }
  }
  return cookiesAsArray.filter(Boolean).join(", ");
}
const setSessionCookie = (headers, sessionToken, expiresAt) => {
  const sessionCookie = cookie.serialize(
    COOKIE_SESSION_TOKEN(),
    sessionToken,
    cookieOptions(headers, expiresAt, true)
  );
  const newCookies = replaceOrAppendValueInSetCookieHeader(
    headers,
    COOKIE_SESSION_TOKEN(),
    sessionCookie
  );
  headers.set("Set-Cookie", newCookies);
};
const setAnonymousSessionCookie = (headers, token, expiresAt) => {
  const anonCookie = cookie.serialize(
    COOKIE_ANONYMOUS_SESSION_TOKEN(),
    token,
    cookieOptions(headers, expiresAt, true)
  );
  const newCookies = replaceOrAppendValueInSetCookieHeader(
    headers,
    COOKIE_ANONYMOUS_SESSION_TOKEN(),
    anonCookie
  );
  headers.set("Set-Cookie", newCookies);
};
const setCSRFCookie = (headers, antiCSRFToken, expiresAt) => {
  debug("setCSRFCookie", antiCSRFToken);
  assert(antiCSRFToken !== void 0, "Internal error: antiCSRFToken is being set to undefined");
  const csrfCookie = cookie.serialize(
    COOKIE_CSRF_TOKEN(),
    antiCSRFToken,
    cookieOptions(headers, expiresAt, false)
  );
  const newCookies = replaceOrAppendValueInSetCookieHeader(headers, COOKIE_CSRF_TOKEN(), csrfCookie);
  headers.set("Set-Cookie", newCookies);
};
const setPublicDataCookie = (headers, publicDataToken, expiresAt) => {
  headers.set(HEADER_PUBLIC_DATA_TOKEN, "updated");
  const publicDataCookie = cookie.serialize(
    COOKIE_PUBLIC_DATA_TOKEN(),
    publicDataToken,
    cookieOptions(headers, expiresAt, false)
  );
  const newCookies = replaceOrAppendValueInSetCookieHeader(
    headers,
    COOKIE_PUBLIC_DATA_TOKEN(),
    publicDataCookie
  );
  headers.set("Set-Cookie", newCookies);
};
function getSessionKernel(_0) {
  return __async$1(this, arguments, function* ({
    headers,
    method
  }) {
    var _a;
    const cookies = getCookiesFromHeader(headers);
    const anonymousSessionToken = cookies[COOKIE_ANONYMOUS_SESSION_TOKEN()];
    const sessionToken = cookies[COOKIE_SESSION_TOKEN()];
    const idRefreshToken = cookies[COOKIE_REFRESH_TOKEN()];
    const antiCSRFToken = headers.get(HEADER_CSRF);
    debug("getSessionKernel", {
      anonymousSessionToken,
      sessionToken,
      idRefreshToken,
      antiCSRFToken
    });
    const enableCsrfProtection = method !== "GET" && method !== "OPTIONS" && method !== "HEAD" && !process.env.DANGEROUSLY_DISABLE_CSRF_PROTECTION;
    if (sessionToken) {
      debug("[getSessionKernel] Request has sessionToken");
      const { handle, version, hashedPublicData } = parseSessionToken(sessionToken);
      if (!handle) {
        debug("No handle in sessionToken");
        return null;
      }
      if (version !== SESSION_TOKEN_VERSION_0) {
        console.log(
          new AuthenticationError("Session token version is not " + SESSION_TOKEN_VERSION_0)
        );
        return null;
      }
      debug("(global as any) session config", global.sessionConfig);
      const persistedSession = yield global.sessionConfig.getSession(handle);
      if (!persistedSession) {
        debug("Session not found in DB");
        return null;
      }
      if (!persistedSession.antiCSRFToken) {
        throw new Error("Internal error: persistedSession.antiCSRFToken is empty");
      }
      if (persistedSession.hashedSessionToken !== hash256(sessionToken)) {
        debug("sessionToken hash did not match");
        debug("persisted: ", persistedSession.hashedSessionToken);
        debug("in req: ", hash256(sessionToken));
        return null;
      }
      if (persistedSession.expiresAt && isPast(persistedSession.expiresAt)) {
        debug("Session expired");
        return null;
      }
      if (enableCsrfProtection && persistedSession.antiCSRFToken !== antiCSRFToken) {
        if (!antiCSRFToken) {
          console.warn(
            `This request is missing the ${HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`
          );
        }
        headers.set(HEADER_CSRF_ERROR, "true");
        throw new CSRFTokenMismatchError();
      }
      if (method !== "GET") {
        const hasPublicDataChanged = hash256((_a = persistedSession.publicData) != null ? _a : void 0) !== hashedPublicData;
        if (hasPublicDataChanged) {
          debug("PublicData has changed since the last request");
        }
        const hasQuarterExpiryTimePassed = persistedSession.expiresAt && differenceInMinutes(persistedSession.expiresAt, new Date()) < 0.75 * global.sessionConfig.sessionExpiryMinutes;
        if (hasQuarterExpiryTimePassed) {
          debug("quarter expiry time has passed");
          debug("Persisted expire time", persistedSession.expiresAt);
        }
        if (hasPublicDataChanged || hasQuarterExpiryTimePassed) {
          yield refreshSession(
            headers,
            {
              handle,
              publicData: JSON.parse(persistedSession.publicData || ""),
              jwtPayload: null,
              antiCSRFToken: persistedSession.antiCSRFToken,
              sessionToken
            },
            { publicDataChanged: hasPublicDataChanged }
          );
        }
      }
      return {
        handle,
        publicData: JSON.parse(persistedSession.publicData || ""),
        jwtPayload: null,
        antiCSRFToken: persistedSession.antiCSRFToken,
        sessionToken
      };
    } else if (idRefreshToken) {
      return null;
    } else if (anonymousSessionToken) {
      debug("Request has anonymousSessionToken");
      const payload = parseAnonymousSessionToken(anonymousSessionToken);
      if (!payload) {
        debug("Payload empty");
        return null;
      }
      if (enableCsrfProtection && payload.antiCSRFToken !== antiCSRFToken) {
        if (!antiCSRFToken) {
          console.warn(
            `This request is missing the ${HEADER_CSRF} header. You can learn about adding this here: https://blitzjs.com/docs/session-management#manual-api-requests`
          );
        }
        headers.set(HEADER_CSRF_ERROR, "true");
        throw new CSRFTokenMismatchError();
      }
      return {
        handle: payload.handle,
        publicData: payload.publicData,
        antiCSRFToken: payload.antiCSRFToken,
        jwtPayload: payload,
        anonymousSessionToken
      };
    }
    return null;
  });
}
function createNewSession(args) {
  return __async$1(this, null, function* () {
    var _a, _b;
    assert(args.publicData.userId !== void 0, "You must provide publicData.userId");
    const antiCSRFToken = createAntiCSRFToken();
    if (args.anonymous) {
      debug("Creating new anonymous session");
      const handle = generateAnonymousSessionHandle();
      const payload = {
        isAnonymous: true,
        handle,
        publicData: args.publicData,
        antiCSRFToken
      };
      const anonymousSessionToken = createAnonymousSessionToken(payload);
      const publicDataToken = createPublicDataToken(args.publicData);
      const expiresAt = addMinutes(
        new Date(),
        global.sessionConfig.anonSessionExpiryMinutes
      );
      setAnonymousSessionCookie(args.headers, anonymousSessionToken, expiresAt);
      setCSRFCookie(args.headers, antiCSRFToken, expiresAt);
      setPublicDataCookie(args.headers, publicDataToken, expiresAt);
      setSessionCookie(args.headers, "", new Date(0));
      args.headers.set(HEADER_SESSION_CREATED, "true");
      return {
        handle,
        publicData: args.publicData,
        jwtPayload: payload,
        antiCSRFToken,
        anonymousSessionToken
      };
    } else if (global.sessionConfig.method === "essential") {
      debug("Creating new session");
      const newPublicData = __spreadValues$1(__spreadValues$1({}, ((_a = args.jwtPayload) == null ? void 0 : _a.publicData) || {}), args.publicData);
      assert(newPublicData.userId, "You must provide a non-empty userId as publicData.userId");
      let existingPrivateData = {};
      if ((_b = args.jwtPayload) == null ? void 0 : _b.isAnonymous) {
        const session = yield global.sessionConfig.getSession(args.jwtPayload.handle);
        if (session) {
          if (session.privateData) {
            existingPrivateData = JSON.parse(session.privateData);
          }
          yield global.sessionConfig.deleteSession(args.jwtPayload.handle);
        }
      }
      const newPrivateData = __spreadValues$1(__spreadValues$1({}, existingPrivateData), args.privateData);
      const expiresAt = addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);
      const handle = generateEssentialSessionHandle();
      const sessionToken = createSessionToken(handle, newPublicData);
      const publicDataToken = createPublicDataToken(newPublicData);
      yield global.sessionConfig.createSession({
        expiresAt,
        handle,
        userId: newPublicData.userId,
        hashedSessionToken: hash256(sessionToken),
        antiCSRFToken,
        publicData: JSON.stringify(newPublicData),
        privateData: JSON.stringify(newPrivateData)
      });
      setSessionCookie(args.headers, sessionToken, expiresAt);
      debug("Session created", { handle, publicData: newPublicData, expiresAt });
      setCSRFCookie(args.headers, antiCSRFToken, expiresAt);
      setPublicDataCookie(args.headers, publicDataToken, expiresAt);
      setAnonymousSessionCookie(args.headers, "", new Date(0));
      args.headers.set(HEADER_SESSION_CREATED, "true");
      return {
        handle,
        publicData: newPublicData,
        jwtPayload: null,
        antiCSRFToken,
        sessionToken
      };
    } else if (global.sessionConfig.method === "advanced") {
      throw new Error("The advanced method is not yet supported");
    } else {
      throw new Error(
        `Session management method ${global.sessionConfig.method} is invalid. Supported methods are "essential" and "advanced"`
      );
    }
  });
}
function createAnonymousSession(_0) {
  return __async$1(this, arguments, function* ({ headers }) {
    return yield createNewSession({
      headers,
      publicData: { userId: null },
      anonymous: true
    });
  });
}
function refreshSession(_0, _1, _2) {
  return __async$1(this, arguments, function* (headers, sessionKernel, { publicDataChanged }) {
    var _a;
    debug("Refreshing session", sessionKernel);
    if ((_a = sessionKernel.jwtPayload) == null ? void 0 : _a.isAnonymous) {
      const payload = __spreadProps$1(__spreadValues$1({}, sessionKernel.jwtPayload), {
        publicData: sessionKernel.publicData
      });
      const anonymousSessionToken = createAnonymousSessionToken(payload);
      const publicDataToken = createPublicDataToken(sessionKernel.publicData);
      const expiresAt = addYears(new Date(), 30);
      setAnonymousSessionCookie(headers, anonymousSessionToken, expiresAt);
      setPublicDataCookie(headers, publicDataToken, expiresAt);
    } else if (global.sessionConfig.method === "essential" && "sessionToken" in sessionKernel) {
      const expiresAt = addMinutes(new Date(), global.sessionConfig.sessionExpiryMinutes);
      debug("Updating session in db with", { expiresAt });
      if (publicDataChanged) {
        debug("Public data has changed");
        const publicDataToken = createPublicDataToken(sessionKernel.publicData);
        setPublicDataCookie(headers, publicDataToken, expiresAt);
        yield global.sessionConfig.updateSession(sessionKernel.handle, {
          expiresAt,
          publicData: JSON.stringify(sessionKernel.publicData)
        });
      } else {
        yield global.sessionConfig.updateSession(sessionKernel.handle, {
          expiresAt
        });
      }
    } else if (global.sessionConfig.method === "advanced") {
      throw new Error("refreshSession() not implemented for advanced method");
    }
  });
}
function getAllSessionHandlesForUser(userId) {
  return __async$1(this, null, function* () {
    return (yield global.sessionConfig.getSessions(userId)).map((session) => session.handle);
  });
}
function syncPubicDataFieldsForUserIfNeeded(userId, data) {
  return __async$1(this, null, function* () {
    var _a;
    const dataToSync = {};
    (_a = global.sessionConfig.publicDataKeysToSyncAcrossSessions) == null ? void 0 : _a.forEach((key) => {
      if (data[key]) {
        dataToSync[key] = data[key];
      }
    });
    if (Object.keys(dataToSync).length) {
      const sessions = yield global.sessionConfig.getSessions(userId);
      for (const session of sessions) {
        const publicData = JSON.stringify(__spreadValues$1(__spreadValues$1({}, session.publicData ? JSON.parse(session.publicData) : {}), dataToSync));
        yield global.sessionConfig.updateSession(session.handle, { publicData });
      }
    }
  });
}
function revokeSession(headers, handle, anonymous = false) {
  return __async$1(this, null, function* () {
    debug("Revoking session", handle);
    if (!anonymous) {
      try {
        yield global.sessionConfig.deleteSession(handle);
      } catch (error) {
      }
    }
    return createAnonymousSession({
      headers
    });
  });
}
function revokeAllSessionsForUser(userId) {
  return __async$1(this, null, function* () {
    let sessionHandles = (yield global.sessionConfig.getSessions(userId)).map(
      (session) => session.handle
    );
    let revoked = [];
    for (const handle of sessionHandles) {
      try {
        yield global.sessionConfig.deleteSession(handle);
      } catch (error) {
      }
      revoked.push(handle);
    }
    return revoked;
  });
}
function getPublicData(sessionKernel) {
  return __async$1(this, null, function* () {
    var _a, _b;
    if ((_a = sessionKernel.jwtPayload) == null ? void 0 : _a.publicData) {
      return (_b = sessionKernel.jwtPayload) == null ? void 0 : _b.publicData;
    } else {
      const session = yield global.sessionConfig.getSession(sessionKernel.handle);
      if (!session) {
        throw new Error("getPublicData() failed because handle doesn't exist " + sessionKernel.handle);
      }
      if (session.publicData) {
        return JSON.parse(session.publicData);
      } else {
        return {};
      }
    }
  });
}
function getPrivateData(handle) {
  return __async$1(this, null, function* () {
    const session = yield global.sessionConfig.getSession(handle);
    if (session && session.privateData) {
      return JSON.parse(session.privateData);
    } else {
      return null;
    }
  });
}
function setPrivateData(sessionKernel, data) {
  return __async$1(this, null, function* () {
    let existingPrivateData = yield getPrivateData(sessionKernel.handle);
    if (existingPrivateData === null) {
      try {
        yield global.sessionConfig.createSession({
          handle: sessionKernel.handle
        });
      } catch (error) {
      }
      existingPrivateData = {};
    }
    const privateData = JSON.stringify(__spreadValues$1(__spreadValues$1({}, existingPrivateData), data));
    yield global.sessionConfig.updateSession(sessionKernel.handle, {
      privateData
    });
  });
}
function setPublicData(headers, sessionKernel, data) {
  return __async$1(this, null, function* () {
    delete data.userId;
    const publicData = __spreadValues$1(__spreadValues$1({}, yield getPublicData(sessionKernel)), data);
    yield refreshSession(headers, __spreadProps$1(__spreadValues$1({}, sessionKernel), { publicData }), { publicDataChanged: true });
    return publicData;
  });
}
function setPublicDataForUser(userId, data) {
  return __async$1(this, null, function* () {
    delete data.userId;
    const sessions = yield global.sessionConfig.getSessions(userId);
    for (const session of sessions) {
      const publicData = JSON.stringify(__spreadValues$1(__spreadValues$1({}, JSON.parse(session.publicData || "")), data));
      yield global.sessionConfig.updateSession(session.handle, { publicData });
    }
  });
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const PrismaStorage = (db) => {
  return {
    getSession: (handle) => db.session.findFirst({ where: { handle } }),
    getSessions: (userId) => db.session.findMany({ where: { userId, expiresAt: { gt: new Date() } } }),
    createSession: (session) => {
      let user;
      if (session.userId) {
        user = { connect: { id: session.userId } };
      }
      return db.session.create({
        data: __spreadProps(__spreadValues({}, session), { userId: void 0, user })
      });
    },
    updateSession: (handle, session) => __async(void 0, null, function* () {
      try {
        return yield db.session.update({ where: { handle }, data: session });
      } catch (error) {
        if (error.code === "P2016") {
          console.warn("Could not update session because it's not in the DB");
        } else {
          throw error;
        }
      }
    }),
    deleteSession: (handle) => db.session.delete({ where: { handle } })
  };
};
const defaultConfig_ = {
  sessionExpiryMinutes: 30 * 24 * 60,
  anonSessionExpiryMinutes: 5 * 365 * 24 * 60,
  method: "essential",
  sameSite: "lax",
  publicDataKeysToSyncAcrossSessions: ["role", "roles"],
  secureCookies: !process.env.DISABLE_SECURE_COOKIES && process.env.NODE_ENV === "production"
};
const AuthServerPlugin = createServerPlugin((options) => {
  globalThis.__BLITZ_SESSION_COOKIE_PREFIX = options.cookiePrefix || "blitz";
  globalThis.sessionConfig = __spreadValues(__spreadValues(__spreadValues({}, defaultConfig_), options.storage), options);
  function authPluginSessionMiddleware() {
    var _a;
    assert(
      options.isAuthorized,
      "You must provide an authorization implementation to sessionMiddleware as isAuthorized(userRoles, input)"
    );
    global.sessionConfig = __spreadValues(__spreadValues(__spreadValues({}, defaultConfig_), options.storage), options);
    const cookiePrefix = (_a = global.sessionConfig.cookiePrefix) != null ? _a : "blitz";
    assert(
      cookiePrefix.match(/^[a-zA-Z0-9-_]+$/),
      `The cookie prefix used has invalid characters. Only alphanumeric characters, "-"  and "_" character are supported`
    );
    const blitzSessionMiddleware = (req, res, next) => __async(this, null, function* () {
      var _a2;
      if (!((_a2 = res.blitzCtx) == null ? void 0 : _a2.session)) {
        yield getSession(req, res);
      }
      return next();
    });
    blitzSessionMiddleware.config = {
      name: "blitzSessionMiddleware",
      cookiePrefix
    };
    return blitzSessionMiddleware;
  }
  if (!globalThis.__BLITZ_GET_RSC_CONTEXT) {
    globalThis.__BLITZ_GET_RSC_CONTEXT = getBlitzContext;
  }
  function withBlitzAuth(handlers) {
    return Object.fromEntries(
      Object.entries(handlers).map(([method, handler]) => [
        method,
        (request, params) => __async(this, null, function* () {
          const session = yield getSession(request);
          const response = yield handler(request, params, { session });
          session.setSession(response);
          return response;
        })
      ])
    );
  }
  return {
    requestMiddlewares: [authPluginSessionMiddleware()],
    exports: () => ({
      getBlitzContext,
      useAuthenticatedBlitzContext,
      withBlitzAuth
    })
  };
});

export { AuthServerPlugin as A, PrismaStorage as P, SessionContextClass as S, getCookieParser as a, getSession as b, simpleRolesIsAuthorized as c, generateToken as d, getAllSessionHandlesForUser as g, hash256 as h, isLocalhost as i, setPublicDataForUser as s };
