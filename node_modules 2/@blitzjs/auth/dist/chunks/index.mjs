import { fromBase64 } from 'b64-lite';
import _BadBehavior from 'bad-behavior';
import React from 'react';
import { createClientPlugin, CSRFTokenMismatchError, assert, readCookie, isServer, isClient, AuthenticationError, RedirectError, deleteCookie } from 'blitz';
import _debug from 'debug';

const TOKEN_SEPARATOR = ";";
const HANDLE_SEPARATOR = ":";
const SESSION_TYPE_OPAQUE_TOKEN_SIMPLE = "ots";
const SESSION_TYPE_ANONYMOUS_JWT = "ajwt";
const SESSION_TOKEN_VERSION_0 = "v0";
const prefix = () => {
  if (!globalThis.__BLITZ_SESSION_COOKIE_PREFIX) {
    throw new Error("Internal Blitz Error: globalThis.__BLITZ_SESSION_COOKIE_PREFIX is not set");
  }
  return globalThis.__BLITZ_SESSION_COOKIE_PREFIX;
};
const COOKIE_ANONYMOUS_SESSION_TOKEN = () => `${prefix()}_sAnonymousSessionToken`;
const COOKIE_SESSION_TOKEN = () => `${prefix()}_sSessionToken`;
const COOKIE_REFRESH_TOKEN = () => `${prefix()}_sIdRefreshToken`;
const COOKIE_CSRF_TOKEN = () => `${prefix()}_sAntiCsrfToken`;
const COOKIE_PUBLIC_DATA_TOKEN = () => `${prefix()}_sPublicDataToken`;
const HEADER_CSRF = "anti-csrf";
const HEADER_PUBLIC_DATA_TOKEN = "public-data-token";
const HEADER_SESSION_CREATED = "session-created";
const HEADER_CSRF_ERROR = "csrf-error";
const LOCALSTORAGE_PREFIX = "_blitz-";
const LOCALSTORAGE_CSRF_TOKEN = () => `${prefix()}_sAntiCsrfToken`;
const LOCALSTORAGE_PUBLIC_DATA_TOKEN = () => `${prefix()}_sPublicDataToken`;

const urlObjectKeys = [
  "auth",
  "hash",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "slashes"
];
function formatWithValidation(url) {
  if (process.env.NODE_ENV === "development") {
    if (url !== null && typeof url === "object") {
      Object.keys(url).forEach((key) => {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
        }
      });
    }
  }
  return formatUrl(url);
}
function stringifyUrlQueryParam(param) {
  if (typeof param === "string" || typeof param === "number" && !isNaN(param) || typeof param === "boolean") {
    return String(param);
  } else {
    return "";
  }
}
function urlQueryToSearchParams(urlQuery) {
  const result = new URLSearchParams();
  Object.entries(urlQuery).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach((item) => result.append(key, stringifyUrlQueryParam(item)));
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}
const slashedProtocols = /https?|ftp|gopher|file/;
function formatUrl(urlObj) {
  let { auth, hostname } = urlObj;
  let protocol = urlObj.protocol || "";
  let pathname = urlObj.pathname || "";
  let hash = urlObj.hash || "";
  let query = urlObj.query || "";
  let host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ":") + "@" : "";
  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(":") ? `[${hostname}]` : hostname);
    if (urlObj.port) {
      host += ":" + urlObj.port;
    }
  }
  if (query && typeof query === "object") {
    query = String(urlQueryToSearchParams(query));
  }
  let search = urlObj.search || query && `?${query}` || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname[0] !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash[0] !== "#")
    hash = "#" + hash;
  if (search && search[0] !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace("#", "%23");
  return `${protocol}${host}${pathname}${search}${hash}`;
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const BadBehavior = "default" in _BadBehavior ? _BadBehavior.default : _BadBehavior;
const debug = _debug("blitz:auth-client");
const parsePublicDataToken = (token) => {
  assert(token, "[parsePublicDataToken] Failed: token is empty");
  const publicDataStr = fromBase64(token);
  try {
    const publicData = JSON.parse(publicDataStr);
    return {
      publicData
    };
  } catch (error) {
    throw new Error(`[parsePublicDataToken] Failed to parse publicDataStr: ${publicDataStr}`);
  }
};
const emptyPublicData = { userId: null, role: null };
class PublicDataStore {
  constructor() {
    this.eventKey = `${LOCALSTORAGE_PREFIX}publicDataUpdated`;
    this.observable = BadBehavior();
    if (typeof window !== "undefined") {
      this.updateState(void 0, { suppressEvent: true });
      window.addEventListener("storage", (event) => {
        if (event.key === this.eventKey) {
          this.updateState(void 0, { suppressEvent: true });
        }
      });
    }
  }
  updateState(value, opts) {
    if (!(opts == null ? void 0 : opts.suppressEvent)) {
      try {
        localStorage.setItem(this.eventKey, Date.now().toString());
      } catch (err) {
        console.error("LocalStorage is not available", err);
      }
    }
    this.observable.next(value != null ? value : this.getData());
  }
  clear() {
    deleteCookie(COOKIE_PUBLIC_DATA_TOKEN());
    try {
      localStorage.removeItem(LOCALSTORAGE_PUBLIC_DATA_TOKEN());
    } catch (err) {
      console.error("LocalStorage is not available", err);
    }
    this.updateState(emptyPublicData);
  }
  getData() {
    const publicDataToken = this.getToken();
    if (!publicDataToken) {
      return emptyPublicData;
    }
    const { publicData } = parsePublicDataToken(publicDataToken);
    return publicData;
  }
  getToken() {
    try {
      const cookieValue = readCookie(COOKIE_PUBLIC_DATA_TOKEN());
      if (cookieValue) {
        localStorage.setItem(LOCALSTORAGE_PUBLIC_DATA_TOKEN(), cookieValue);
        return cookieValue;
      } else {
        return localStorage.getItem(LOCALSTORAGE_PUBLIC_DATA_TOKEN());
      }
    } catch (err) {
      console.error("LocalStorage is not available", err);
      return void 0;
    }
  }
}
const getPublicDataStore = () => {
  if (!window.__publicDataStore) {
    window.__publicDataStore = new PublicDataStore();
  }
  return window.__publicDataStore;
};
const backupAntiCSRFTokenToLocalStorage = () => {
  const cookieValue = readCookie(COOKIE_CSRF_TOKEN());
  if (cookieValue) {
    localStorage.setItem(LOCALSTORAGE_CSRF_TOKEN(), cookieValue);
  }
};
const getAntiCSRFToken = () => {
  const cookieValue = readCookie(COOKIE_CSRF_TOKEN());
  if (cookieValue) {
    return cookieValue;
  } else {
    return localStorage.getItem(LOCALSTORAGE_CSRF_TOKEN());
  }
};
const useSession = (options = {}) => {
  var _a;
  const suspense = (_a = options == null ? void 0 : options.suspense) != null ? _a : Boolean(globalThis.__BLITZ_SUSPENSE_ENABLED);
  let initialState;
  if (options.initialPublicData) {
    initialState = __spreadProps(__spreadValues({}, options.initialPublicData), { isLoading: false });
  } else if (suspense) {
    if (isServer) {
      const e = new Error();
      e.name = "Rendering Suspense fallback...";
      e.digest = "DYNAMIC_SERVER_USAGE";
      e.message = "DYNAMIC_SERVER_USAGE";
      delete e.stack;
      throw e;
    } else {
      initialState = __spreadProps(__spreadValues({}, getPublicDataStore().getData()), { isLoading: false });
    }
  } else {
    initialState = __spreadProps(__spreadValues({}, emptyPublicData), { isLoading: true });
  }
  const [session, setSession] = React.useState(initialState);
  React.useEffect(() => {
    setSession(__spreadProps(__spreadValues({}, getPublicDataStore().getData()), { isLoading: false }));
    const subscription = getPublicDataStore().observable.subscribe(
      (data) => setSession(__spreadProps(__spreadValues({}, data), { isLoading: false }))
    );
    return subscription.unsubscribe;
  }, []);
  return session;
};
const useAuthorizeIf = (condition, role) => {
  const [mounted, setMounted] = React.useState(false);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  if (isClient && condition && !getPublicDataStore().getData().userId && mounted) {
    const error = new AuthenticationError();
    error.stack = null;
    throw error;
  }
  if (isClient && condition && role && getPublicDataStore().getData().userId && mounted) {
    const error = new AuthenticationError();
    error.stack = null;
    if (!authorizeRole(role, getPublicDataStore().getData().role)) {
      throw error;
    }
  }
};
const authorizeRole = (role, currentRole) => {
  if (role && currentRole) {
    if (Array.isArray(role)) {
      if (role.includes(currentRole)) {
        return true;
      }
    } else {
      if (currentRole === role) {
        return true;
      }
    }
  }
  return false;
};
const useAuthorize = () => {
  useAuthorizeIf(true);
};
const useAuthenticatedSession = (options = {}) => {
  useAuthorize();
  return useSession(options);
};
const useRedirectAuthenticated = (to) => {
  const [mounted, setMounted] = React.useState(false);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  if (isClient && getPublicDataStore().getData().userId && mounted) {
    const error = new RedirectError(to);
    error.stack = null;
    throw error;
  }
};
function getAuthValues(Page, props) {
  var _a, _b, _c;
  if (!Page)
    return {};
  let authenticate = Page == null ? void 0 : Page.authenticate;
  let redirectAuthenticatedTo = Page == null ? void 0 : Page.redirectAuthenticatedTo;
  if (authenticate === void 0 && redirectAuthenticatedTo === void 0) {
    const layout = "getLayout" in Page && ((_a = Page.getLayout) == null ? void 0 : _a.call(Page, /* @__PURE__ */ React.createElement(Page, __spreadValues({}, props))));
    if (layout) {
      let currentElement = layout;
      while (true) {
        const type = layout.type;
        if (type.authenticate !== void 0 || type.redirectAuthenticatedTo !== void 0) {
          authenticate = type.authenticate;
          redirectAuthenticatedTo = type.redirectAuthenticatedTo;
          break;
        }
        if ((_b = currentElement.props) == null ? void 0 : _b.children) {
          currentElement = (_c = currentElement.props) == null ? void 0 : _c.children;
        } else {
          break;
        }
      }
    }
  }
  return { authenticate, redirectAuthenticatedTo };
}
function withBlitzAuthPlugin(Page) {
  const AuthRoot = (props) => {
    useSession({ suspense: false });
    const [mounted, setMounted] = React.useState(false);
    React.useEffect(() => {
      setMounted(true);
    }, []);
    let { authenticate, redirectAuthenticatedTo } = getAuthValues(Page, props);
    useAuthorizeIf(
      !!authenticate && (typeof authenticate === "object" && authenticate.redirectTo === void 0 || authenticate === true),
      !authenticate ? void 0 : typeof authenticate === "object" ? authenticate.role : void 0
    );
    if (typeof window !== "undefined") {
      const publicData = getPublicDataStore().getData();
      if (publicData.userId) {
        debug("[BlitzAuthInnerRoot] logged in");
        if (typeof redirectAuthenticatedTo === "function") {
          redirectAuthenticatedTo = redirectAuthenticatedTo({
            session: publicData
          });
        }
        if (redirectAuthenticatedTo) {
          const redirectUrl = typeof redirectAuthenticatedTo === "string" ? redirectAuthenticatedTo : formatWithValidation(redirectAuthenticatedTo);
          if (mounted) {
            debug("[BlitzAuthInnerRoot] redirecting to", redirectUrl);
            const error = new RedirectError(redirectUrl);
            error.stack = null;
            throw error;
          }
        }
        if (authenticate && typeof authenticate === "object" && authenticate.redirectTo && authenticate.role && !authorizeRole(authenticate.role, publicData.role)) {
          let { redirectTo } = authenticate;
          if (typeof redirectTo !== "string") {
            redirectTo = formatWithValidation(redirectTo);
          }
          const url = new URL(redirectTo, window.location.href);
          url.searchParams.append("next", window.location.pathname);
          debug("[BlitzAuthInnerRoot] redirecting to", url.toString());
          const error = new RedirectError(url.toString());
          error.stack = null;
          throw error;
        }
      } else {
        debug("[BlitzAuthInnerRoot] logged out");
        if (authenticate && typeof authenticate === "object" && authenticate.redirectTo) {
          let { redirectTo } = authenticate;
          if (typeof redirectTo !== "string") {
            redirectTo = formatWithValidation(redirectTo);
          }
          const url = new URL(redirectTo, window.location.href);
          url.searchParams.append("next", window.location.pathname);
          if (mounted) {
            debug("[BlitzAuthInnerRoot] redirecting to", url.toString());
            const error = new RedirectError(url.toString());
            error.stack = null;
            throw error;
          }
        }
      }
    }
    return /* @__PURE__ */ React.createElement(Page, __spreadValues({}, props));
  };
  for (let [key, value] of Object.entries(Page)) {
    AuthRoot[key] = value;
  }
  if (process.env.NODE_ENV !== "production") {
    AuthRoot.displayName = `BlitzAuthInnerRoot`;
  }
  return AuthRoot;
}
const AuthClientPlugin = createClientPlugin((options) => {
  globalThis.__BLITZ_SESSION_COOKIE_PREFIX = options.cookiePrefix || "blitz";
  return {
    withProvider: withBlitzAuthPlugin,
    events: {
      onRpcError: (error) => __async(void 0, null, function* () {
        if (error.name === "AuthenticationError" && getPublicDataStore().getData().userId) {
          getPublicDataStore().clear();
        }
      })
    },
    middleware: {
      beforeHttpRequest(req) {
        const headers = {
          "Content-Type": "application/json"
        };
        const antiCSRFToken = getAntiCSRFToken();
        if (antiCSRFToken) {
          debug("Adding antiCSRFToken cookie header", antiCSRFToken);
          headers[HEADER_CSRF] = antiCSRFToken;
        } else {
          debug("No antiCSRFToken cookie found");
        }
        req.headers = __spreadValues(__spreadValues({}, req.headers), headers);
        return req;
      },
      beforeHttpResponse(res) {
        if (res.headers) {
          backupAntiCSRFTokenToLocalStorage();
          if (res.headers.get(HEADER_PUBLIC_DATA_TOKEN)) {
            getPublicDataStore().updateState();
            debug("Public data updated");
          }
          if (res.headers.get(HEADER_SESSION_CREATED)) {
            const event = new Event("blitz:session-created");
            document.dispatchEvent(event);
          }
          if (res.headers.get(HEADER_CSRF_ERROR)) {
            const err = new CSRFTokenMismatchError();
            err.stack = null;
            throw err;
          }
        }
        return res;
      }
    },
    exports: () => ({
      useSession,
      useAuthorize,
      useAuthorizeIf,
      useRedirectAuthenticated,
      useAuthenticatedSession,
      getAntiCSRFToken
    })
  };
});

export { AuthClientPlugin as A, COOKIE_ANONYMOUS_SESSION_TOKEN as C, HANDLE_SEPARATOR as H, LOCALSTORAGE_PREFIX as L, SESSION_TYPE_OPAQUE_TOKEN_SIMPLE as S, TOKEN_SEPARATOR as T, getAntiCSRFToken as a, backupAntiCSRFTokenToLocalStorage as b, useAuthorizeIf as c, useAuthorize as d, useAuthenticatedSession as e, useRedirectAuthenticated as f, getPublicDataStore as g, getAuthValues as h, SESSION_TYPE_ANONYMOUS_JWT as i, SESSION_TOKEN_VERSION_0 as j, COOKIE_SESSION_TOKEN as k, COOKIE_REFRESH_TOKEN as l, COOKIE_CSRF_TOKEN as m, COOKIE_PUBLIC_DATA_TOKEN as n, HEADER_CSRF as o, parsePublicDataToken as p, HEADER_PUBLIC_DATA_TOKEN as q, HEADER_SESSION_CREATED as r, HEADER_CSRF_ERROR as s, LOCALSTORAGE_CSRF_TOKEN as t, useSession as u, LOCALSTORAGE_PUBLIC_DATA_TOKEN as v, formatWithValidation as w };
