import { normalizePathTrailingSlash } from 'next/dist/client/normalize-trailing-slash';
import { addBasePath } from 'next/dist/client/add-base-path';
import { serialize, stringify, deserialize } from 'superjson';
import { isClient, isServer, isNotInUserTestEnvironment } from 'blitz';
import '@tanstack/react-query';

const requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
  let start = Date.now();
  return setTimeout(function() {
    cb({
      didTimeout: false,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};
const getQueryClient = () => globalThis.queryClient;
function isRpcClient(f) {
  return !!f._isRpcClient;
}
const getQueryCacheFunctions = (resolver, params) => ({
  setQueryData: (newData, opts = { refetch: true }) => {
    return setQueryData(resolver, params, newData, opts);
  }
});
const emptyQueryFn = (() => {
  const fn = () => new Promise(() => {
  });
  fn._isRpcClient = true;
  return fn;
})();
const validateQueryFn = (queryFn) => {
  if (isClient && !isRpcClient(queryFn) && isNotInUserTestEnvironment()) {
    throw new Error(
      `Either the file path to your resolver is incorrect (must be in a "queries" or "mutations" folder that isn't nested inside "pages" or "api") or you are trying to use Blitz's useQuery to fetch from third-party APIs (to do that, import useQuery directly from "@tanstack/react-query").`
    );
  }
};
const sanitize = (type) => (queryFn) => {
  if (isServer)
    return queryFn;
  validateQueryFn(queryFn);
  const rpcClient = queryFn;
  const queryFnName = type === "mutation" ? "useMutation" : "useQuery";
  if (rpcClient._resolverType !== type && isNotInUserTestEnvironment()) {
    throw new Error(
      `"${queryFnName}" was expected to be called with a ${type} but was called with a "${rpcClient._resolverType}"`
    );
  }
  return rpcClient;
};
const sanitizeQuery = sanitize("query");
const sanitizeMutation = sanitize("mutation");
const getQueryKeyFromUrlAndParams = (url, ...params) => {
  const queryKey = [url];
  if (params.length === 1) {
    const param = params[0];
    queryKey.push(serialize(typeof param === "function" ? param() : param));
  }
  return queryKey;
};
function getQueryKey(resolver, ...params) {
  if (typeof resolver === "undefined") {
    throw new Error("getQueryKey is missing the first argument - it must be a resolver function");
  }
  return getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._routePath, ...params);
}
function getInfiniteQueryKey(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error(
      "getInfiniteQueryKey is missing the first argument - it must be a resolver function"
    );
  }
  const queryKey = getQueryKeyFromUrlAndParams(sanitizeQuery(resolver)._routePath, params);
  return [...queryKey, "infinite"];
}
const invalidateQuery = (resolver = void 0, ...params) => {
  const fullQueryKey = typeof resolver === "undefined" ? void 0 : getQueryKey(resolver, ...params);
  return getQueryClient().invalidateQueries(fullQueryKey);
};
function setQueryData(resolver, params, newData, opts = { refetch: true }) {
  if (typeof resolver === "undefined") {
    throw new Error("setQueryData is missing the first argument - it must be a resolver function");
  }
  const queryKey = getQueryKey(resolver, params);
  return new Promise((res) => {
    getQueryClient().setQueryData(queryKey, newData);
    let result;
    if (opts.refetch) {
      result = invalidateQuery(resolver, params);
    }
    if (isClient) {
      requestIdleCallback(() => {
        res(result);
      });
    } else {
      res(result);
    }
  });
}
function getQueryData(resolver, params) {
  if (typeof resolver === "undefined") {
    throw new Error("getQueryData is missing the first argument - it must be a resolver function");
  }
  const queryKey = getQueryKey(resolver, params);
  return getQueryClient().getQueryData(queryKey);
}

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function normalizeApiRoute(path) {
  return normalizePathTrailingSlash(addBasePath(path));
}
function __internal_buildRpcClient({
  resolverName,
  resolverType,
  routePath,
  httpMethod
}) {
  const fullRoutePath = normalizeApiRoute("/api/rpc" + routePath);
  const routePathURL = new URL(fullRoutePath, window.location.origin);
  const httpClient = (_0, ..._1) => __async(this, [_0, ..._1], function* (params, opts = {}, signal = void 0) {
    const debug = (yield import('debug')).default("blitz:rpc");
    if (!opts.fromQueryHook && !opts.fromInvoke) {
      console.warn(
        "[Deprecation] Directly calling queries/mutations is deprecated in favor of invoke(queryFn, params)"
      );
    }
    if (isServer) {
      return Promise.resolve();
    }
    debug("Starting request for", fullRoutePath, "with", params, "and", opts);
    let serialized;
    if (opts.alreadySerialized) {
      serialized = params;
    } else {
      serialized = serialize(params);
    }
    if (httpMethod === "GET" && serialized.json) {
      routePathURL.searchParams.set("params", stringify(serialized.json));
      routePathURL.searchParams.set("meta", stringify(serialized.meta));
    }
    const { beforeHttpRequest, beforeHttpResponse } = globalThis.__BLITZ_MIDDLEWARE_HOOKS;
    const promise = window.fetch(
      routePathURL,
      beforeHttpRequest({
        method: httpMethod,
        headers: {
          "Content-Type": "application/json"
        },
        credentials: "include",
        redirect: "follow",
        body: httpMethod === "POST" ? JSON.stringify({
          params: serialized.json,
          meta: {
            params: serialized.meta
          }
        }) : void 0,
        signal
      })
    ).then((response) => __async(this, null, function* () {
      var _a, _b;
      debug("Received request for", routePath);
      response = beforeHttpResponse(response);
      if (!response.ok) {
        const error = new Error(response.statusText);
        error.statusCode = response.status;
        error.path = routePath;
        error.stack = null;
        throw error;
      } else {
        let payload;
        try {
          payload = yield response.json();
        } catch (error) {
          const err = new Error(`Failed to parse json from ${routePath}`);
          err.stack = null;
          throw err;
        }
        if (payload.error) {
          let error = deserialize({
            json: payload.error,
            meta: (_a = payload.meta) == null ? void 0 : _a.error
          });
          const rpcEvent = new CustomEvent("blitz:rpc-error", {
            detail: error
          });
          document.dispatchEvent(rpcEvent);
          const prismaError = error.message.match(/invalid.*prisma.*invocation/i);
          if (prismaError && !("code" in error)) {
            error = new Error(prismaError[0]);
            error.statusCode = 500;
          }
          error.stack = null;
          throw error;
        } else {
          const data = deserialize({
            json: payload.result,
            meta: (_b = payload.meta) == null ? void 0 : _b.result
          });
          if (!opts.fromQueryHook) {
            const queryKey = getQueryKeyFromUrlAndParams(routePath, params);
            getQueryClient().setQueryData(queryKey, data);
          }
          return data;
        }
      }
    }));
    return promise;
  });
  const rpcClient = httpClient;
  rpcClient._isRpcClient = true;
  rpcClient._resolverName = resolverName;
  rpcClient._resolverType = resolverType;
  rpcClient._routePath = fullRoutePath;
  return rpcClient;
}

export { __internal_buildRpcClient as _, getInfiniteQueryKey as a, sanitizeMutation as b, getQueryCacheFunctions as c, setQueryData as d, emptyQueryFn as e, getQueryClient as f, getQueryKey as g, getQueryData as h, invalidateQuery as i, normalizeApiRoute as n, sanitizeQuery as s };
