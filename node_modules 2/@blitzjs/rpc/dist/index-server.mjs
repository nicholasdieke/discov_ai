import { assert, baseLogger, prettyMs, newLine } from 'blitz';
import { deserialize, parse, serialize } from 'superjson';
import { resolve } from 'path';
import chalk from 'chalk';
export { BlitzRpcPlugin, invoke, invokeWithCtx, useInfiniteQuery, useMutation, usePaginatedQuery, useQuery } from './index-browser.mjs';
export { _ as __internal_buildRpcClient, a as getInfiniteQueryKey, f as getQueryClient, h as getQueryData, g as getQueryKey, i as invalidateQuery, n as normalizeApiRoute, d as setQueryData } from './chunks/rpc.mjs';
export { QueryClient, QueryClientProvider, dehydrate, useQueryErrorResetBoundary } from '@tanstack/react-query';
import 'next/router';
import 'next/dist/client/normalize-trailing-slash';
import 'next/dist/client/add-base-path';

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isResultWithContext(x) {
  return typeof x === "object" && x !== null && "ctx" in x && x.__blitz === true;
}
function pipe(...args) {
  const functions = args;
  return function(input, ctx) {
    return __async$1(this, null, function* () {
      let lastResult = input;
      for (let fn of functions) {
        lastResult = yield fn(lastResult, ctx);
        if (isResultWithContext(lastResult)) {
          ctx = lastResult.ctx;
          lastResult = lastResult.value;
        }
      }
      return lastResult;
    });
  };
}
const authorize = (...args) => {
  return function _innerAuthorize(input, ctx) {
    const session = ctx.session;
    if (!session)
      throw new Error(
        "You are using the resolver.authorize() function, but `@blitzjs/auth` plugin is not initialized. Ensure it is installed and the auth plugin is added to setupBlitzServer()"
      );
    session.$authorize(...args);
    return {
      __blitz: true,
      value: input,
      ctx
    };
  };
};
function zod(schema, parserType = "async") {
  if (parserType === "sync") {
    return (input) => schema.parse(input);
  } else {
    return (input) => schema.parseAsync(input);
  }
}
const resolver = {
  pipe,
  zod,
  authorize
};

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function isObject(value) {
  return typeof value === "object" && value !== null;
}
const defaultConfig = {
  httpMethod: "POST"
};
function getGlobalObject(key, defaultValue) {
  assert(key.startsWith("__internal_blitz"), "unsupported key");
  if (typeof global === "undefined") {
    return defaultValue;
  }
  assert(isObject(global), "not an object");
  return global[key] = global[key] || defaultValue;
}
const g = getGlobalObject(
  "__internal_blitzRpcResolverFiles",
  {
    blitzRpcResolverFilesLoaded: null
  }
);
function loadBlitzRpcResolverFilesWithInternalMechanism() {
  return g.blitzRpcResolverFilesLoaded;
}
function __internal_addBlitzRpcResolver(routePath, resolver) {
  g.blitzRpcResolverFilesLoaded = g.blitzRpcResolverFilesLoaded || {};
  g.blitzRpcResolverFilesLoaded[routePath] = resolver;
  return resolver;
}
const dir = __dirname + (() => "")();
const loaderClient = resolve(dir, "./loader-client.cjs");
const loaderServer = resolve(dir, "./loader-server.cjs");
const loaderServerResolvers = resolve(dir, "./loader-server-resolvers.cjs");
function installWebpackConfig({
  webpackConfig,
  webpackRuleOptions
}) {
  webpackConfig.resolve.alias["npm-which"] = false;
  webpackConfig.resolve.alias["cross-spawn"] = false;
  webpackConfig.module.rules.push({
    test: /[\\/]\[\[\.\.\.blitz]]?.+\.[jt]sx?$/,
    use: [
      {
        loader: loaderServer,
        options: webpackRuleOptions
      }
    ]
  });
  webpackConfig.module.rules.push({
    test: /[\\/](queries|mutations)[\\/]/,
    use: [
      {
        loader: loaderClient,
        options: webpackRuleOptions
      },
      {
        loader: loaderServerResolvers,
        options: webpackRuleOptions
      }
    ]
  });
}
function getResolverMap() {
  return __async(this, null, function* () {
    {
      const resolverFilesLoaded = loadBlitzRpcResolverFilesWithInternalMechanism();
      if (resolverFilesLoaded) {
        return resolverFilesLoaded;
      }
    }
  });
}
function rpcHandler(config) {
  return function handleRpcRequest(req, res, ctx) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const resolverMap = yield getResolverMap();
      assert(resolverMap, "No query or mutation resolvers found");
      assert(
        Array.isArray(req.query.blitz),
        "It seems your Blitz RPC endpoint file is not named [[...blitz]].(jt)s. Please ensure it is"
      );
      const relativeRoutePath = (_a = req.query.blitz) == null ? void 0 : _a.join("/");
      const routePath = "/" + relativeRoutePath;
      const log = baseLogger().getChildLogger({
        prefix: [routePath.replace(/(\/api\/rpc)?\//, "") + "()"]
      });
      const customChalk = new chalk.Instance({
        level: log.settings.type === "json" ? 0 : chalk.level
      });
      const loadableResolver = resolverMap == null ? void 0 : resolverMap[routePath];
      if (!loadableResolver) {
        throw new Error("No resolver for path: " + routePath);
      }
      const { default: resolver, config: resolverConfig } = yield loadableResolver();
      if (!resolver) {
        throw new Error("No default export for resolver path: " + routePath);
      }
      const resolverConfigWithDefaults = __spreadValues(__spreadValues({}, defaultConfig), resolverConfig);
      if (req.method === "HEAD") {
        res.status(200).end();
        return;
      } else if (req.method === "POST" || req.method === "GET" && resolverConfigWithDefaults.httpMethod === "GET") {
        if (req.method === "POST" && typeof req.body.params === "undefined") {
          const error = { message: "Request body is missing the `params` key" };
          log.error(error.message);
          res.status(400).json({
            result: null,
            error
          });
          return;
        }
        try {
          const data = deserialize({
            json: req.method === "POST" ? req.body.params : req.query.params ? parse(`${req.query.params}`) : void 0,
            meta: req.method === "POST" ? (_b = req.body.meta) == null ? void 0 : _b.params : req.query.meta ? parse(`${req.query.meta}`) : void 0
          });
          log.info(customChalk.dim("Starting with input:"), data ? data : JSON.stringify(data));
          const startTime = Date.now();
          const result = yield resolver(data, res.blitzCtx);
          const resolverDuration = Date.now() - startTime;
          log.debug(customChalk.dim("Result:"), result ? result : JSON.stringify(result));
          const serializerStartTime = Date.now();
          const serializedResult = serialize(result);
          const nextSerializerStartTime = Date.now();
          res.blitzResult = result;
          res.json({
            result: serializedResult.json,
            error: null,
            meta: {
              result: serializedResult.meta
            }
          });
          log.debug(
            customChalk.dim(
              `Next.js serialization:${prettyMs(Date.now() - nextSerializerStartTime)}`
            )
          );
          const serializerDuration = Date.now() - serializerStartTime;
          const duration = Date.now() - startTime;
          log.info(
            customChalk.dim(
              `Finished: resolver:${prettyMs(resolverDuration)} serializer:${prettyMs(
                serializerDuration
              )} total:${prettyMs(duration)}`
            )
          );
          newLine();
          return;
        } catch (error) {
          if (error._clearStack) {
            delete error.stack;
          }
          (_c = config.onError) == null ? void 0 : _c.call(config, error);
          log.error(error);
          newLine();
          if (!error.statusCode) {
            error.statusCode = 500;
          }
          const serializedError = serialize(error);
          res.json({
            result: null,
            error: serializedError.json,
            meta: {
              error: serializedError.meta
            }
          });
          return;
        }
      } else {
        log.warn(`${req.method} method not supported`);
        res.status(404).end();
        return;
      }
    });
  };
}

export { __internal_addBlitzRpcResolver, installWebpackConfig, loadBlitzRpcResolverFilesWithInternalMechanism, resolver, rpcHandler };
