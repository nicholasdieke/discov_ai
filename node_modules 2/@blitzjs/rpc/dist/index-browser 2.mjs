import { isServer, isClient, createClientPlugin } from 'blitz';
import { useQuery as useQuery$1, useInfiniteQuery as useInfiniteQuery$1, useMutation as useMutation$1, QueryClient } from '@tanstack/react-query';
export { QueryClient, QueryClientProvider, dehydrate, useQueryErrorResetBoundary } from '@tanstack/react-query';
import { s as sanitizeQuery, g as getQueryKey, a as getInfiniteQueryKey, b as sanitizeMutation, e as emptyQueryFn, c as getQueryCacheFunctions } from './chunks/rpc.mjs';
export { _ as __internal_buildRpcClient, a as getInfiniteQueryKey, f as getQueryClient, h as getQueryData, g as getQueryKey, i as invalidateQuery, n as normalizeApiRoute, d as setQueryData } from './chunks/rpc.mjs';
import { useRouter } from 'next/router';
import 'next/dist/client/normalize-trailing-slash';
import 'next/dist/client/add-base-path';
import 'superjson';

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
class NextError extends Error {
}
function useQuery(queryFn, params, options = {}) {
  var _a;
  if (typeof queryFn === "undefined") {
    throw new Error("useQuery is missing the first argument - it must be a query function");
  }
  const suspenseEnabled = Boolean(globalThis.__BLITZ_SUSPENSE_ENABLED);
  let enabled = isServer && suspenseEnabled ? false : (_a = options == null ? void 0 : options.enabled) != null ? _a : (options == null ? void 0 : options.enabled) !== null;
  enabled === false ? false : options == null ? void 0 : options.suspense;
  const routerIsReady = useRouter().isReady || isServer && suspenseEnabled;
  const enhancedResolverRpcClient = sanitizeQuery(queryFn);
  const queryKey = getQueryKey(queryFn, params);
  const _b = useQuery$1(__spreadProps$1(__spreadValues$1({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? ({ signal }) => enhancedResolverRpcClient(params, { fromQueryHook: true }, signal) : emptyQueryFn
  }, options), {
    enabled
  })), { data } = _b, queryRest = __objRest(_b, ["data"]);
  if (queryRest.fetchStatus === "idle" && isServer && suspenseEnabled !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    const e = new NextError();
    e.name = "Rendering Suspense fallback...";
    e.digest = "DYNAMIC_SERVER_USAGE";
    e.message = "DYNAMIC_SERVER_USAGE";
    delete e.stack;
    throw e;
  }
  const rest = __spreadValues$1(__spreadValues$1({}, queryRest), getQueryCacheFunctions(queryFn, params));
  return [data, rest];
}
function usePaginatedQuery(queryFn, params, options = {}) {
  var _a;
  if (typeof queryFn === "undefined") {
    throw new Error("usePaginatedQuery is missing the first argument - it must be a query function");
  }
  const suspenseEnabled = Boolean(globalThis.__BLITZ_SUSPENSE_ENABLED);
  let enabled = isServer && suspenseEnabled ? false : (_a = options == null ? void 0 : options.enabled) != null ? _a : (options == null ? void 0 : options.enabled) !== null;
  enabled === false ? false : options == null ? void 0 : options.suspense;
  const routerIsReady = useRouter().isReady || isServer && suspenseEnabled;
  const enhancedResolverRpcClient = sanitizeQuery(queryFn);
  const queryKey = getQueryKey(queryFn, params);
  const _b = useQuery$1(__spreadProps$1(__spreadValues$1({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? ({ signal }) => enhancedResolverRpcClient(params, { fromQueryHook: true }, signal) : emptyQueryFn
  }, options), {
    keepPreviousData: true,
    enabled
  })), { data } = _b, queryRest = __objRest(_b, ["data"]);
  if (queryRest.fetchStatus === "idle" && isServer && suspenseEnabled !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    const e = new NextError();
    e.name = "Rendering Suspense fallback...";
    e.digest = "DYNAMIC_SERVER_USAGE";
    e.message = "DYNAMIC_SERVER_USAGE";
    delete e.stack;
    throw e;
  }
  const rest = __spreadValues$1(__spreadValues$1({}, queryRest), getQueryCacheFunctions(queryFn, params));
  return [data, rest];
}
function useInfiniteQuery(queryFn, getQueryParams, options) {
  var _a;
  if (typeof queryFn === "undefined") {
    throw new Error("useInfiniteQuery is missing the first argument - it must be a query function");
  }
  const suspenseEnabled = Boolean(globalThis.__BLITZ_SUSPENSE_ENABLED);
  let enabled = isServer && suspenseEnabled ? false : (_a = options == null ? void 0 : options.enabled) != null ? _a : (options == null ? void 0 : options.enabled) !== null;
  enabled === false ? false : options == null ? void 0 : options.suspense;
  const routerIsReady = useRouter().isReady || isServer && suspenseEnabled;
  const enhancedResolverRpcClient = sanitizeQuery(queryFn);
  const queryKey = getInfiniteQueryKey(queryFn, getQueryParams);
  const _b = useInfiniteQuery$1(__spreadProps$1(__spreadValues$1({
    queryKey: routerIsReady ? queryKey : ["_routerNotReady_"],
    queryFn: routerIsReady ? ({ pageParam, signal }) => enhancedResolverRpcClient(getQueryParams(pageParam), { fromQueryHook: true }, signal) : emptyQueryFn
  }, options), {
    enabled
  })), { data } = _b, queryRest = __objRest(_b, ["data"]);
  if (queryRest.fetchStatus === "idle" && isServer && suspenseEnabled !== false && !data && (!options || !("suspense" in options) || options.suspense) && (!options || !("enabled" in options) || options.enabled)) {
    const e = new NextError();
    e.name = "Rendering Suspense fallback...";
    e.digest = "DYNAMIC_SERVER_USAGE";
    e.message = "DYNAMIC_SERVER_USAGE";
    delete e.stack;
    throw e;
  }
  const rest = __spreadProps$1(__spreadValues$1(__spreadValues$1({}, queryRest), getQueryCacheFunctions(queryFn, getQueryParams)), {
    pageParams: data == null ? void 0 : data.pageParams
  });
  return [data == null ? void 0 : data.pages, rest];
}
function useMutation(mutationResolver, config) {
  const enhancedResolverRpcClient = sanitizeMutation(mutationResolver);
  const _a = useMutation$1(
    (variables) => enhancedResolverRpcClient(variables, { fromQueryHook: true }),
    __spreadValues$1({
      throwOnError: true
    }, config)
  ), { mutate, mutateAsync } = _a, rest = __objRest(_a, ["mutate", "mutateAsync"]);
  return [mutateAsync, rest];
}

function invoke(queryFn, params) {
  if (typeof queryFn === "undefined") {
    throw new Error(
      "invoke is missing the first argument - it must be a query or mutation function"
    );
  }
  if (isClient) {
    const fn = queryFn;
    return fn(params, { fromInvoke: true });
  } else {
    const fn = queryFn;
    return fn(params);
  }
}

function invokeWithCtx(queryFn, params, ctx) {
  if (typeof queryFn === "undefined") {
    throw new Error(
      "invokeWithCtx is missing the first argument - it must be a query or mutation function"
    );
  }
  return queryFn(params, ctx);
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const BlitzRpcPlugin = createClientPlugin(
  (options) => {
    const initializeQueryClient = () => {
      var _a, _b;
      const { reactQueryOptions } = options || {};
      let suspenseEnabled = (_b = (_a = reactQueryOptions == null ? void 0 : reactQueryOptions.queries) == null ? void 0 : _a.suspense) != null ? _b : true;
      if (!process.env.CLI_COMMAND_CONSOLE && !process.env.CLI_COMMAND_DB) {
        globalThis.__BLITZ_SUSPENSE_ENABLED = suspenseEnabled;
      }
      return new QueryClient({
        defaultOptions: __spreadProps(__spreadValues({}, reactQueryOptions), {
          queries: __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, typeof window === "undefined" && { cacheTime: 0 }), {
            retry: (failureCount, error) => {
              if (process.env.NODE_ENV !== "production")
                return false;
              if (error.message === "Network request failed" && failureCount <= 3)
                return true;
              return false;
            }
          }), reactQueryOptions == null ? void 0 : reactQueryOptions.queries), {
            suspense: suspenseEnabled
          })
        })
      });
    };
    const queryClient = initializeQueryClient();
    function resetQueryClient() {
      setTimeout(() => __async(this, null, function* () {
        const debug = (yield import('debug')).default("blitz:rpc");
        debug("Invalidating react-query cache...");
        yield queryClient.cancelQueries();
        yield queryClient.resetQueries();
        queryClient.getMutationCache().clear();
      }), 100);
    }
    globalThis.queryClient = queryClient;
    return {
      events: {
        onSessionCreated: () => __async(void 0, null, function* () {
          resetQueryClient();
        })
      },
      middleware: {},
      exports: () => ({
        queryClient
      })
    };
  }
);

export { BlitzRpcPlugin, invoke, invokeWithCtx, useInfiniteQuery, useMutation, usePaginatedQuery, useQuery };
