import { join } from 'path';
import { promises } from 'fs';
import { b as buildPageExtensionRegex, t as toPosixPath, a as assertPosixPath, c as convertPageFilePathToRoutePath, d as topLevelFoldersThatMayContainResolvers, g as getIsRpcFile } from './chunks/loader-utils.mjs';
import 'blitz';

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function loader(input) {
  return __async(this, null, function* () {
    const compiler = this._compiler;
    const id = this.resource;
    const root = this._compiler.context;
    const rpcFolders = this.query.includeRPCFolders ? this.query.includeRPCFolders : [];
    const isSSR = compiler.name === "server";
    if (isSSR) {
      this.cacheable(false);
      const resolvers = yield collectResolvers(root, rpcFolders, ["ts", "js"]);
      return yield transformBlitzRpcServer(
        input,
        toPosixPath(id),
        toPosixPath(root),
        resolvers,
        this.query
      );
    }
    return input;
  });
}
module.exports = loader;
function slash(str) {
  return str.replace(/\\/g, "/");
}
function transformBlitzRpcServer(src, id, root, resolvers, options) {
  return __async(this, null, function* () {
    assertPosixPath(id);
    assertPosixPath(root);
    const blitzImport = 'import { __internal_addBlitzRpcResolver } from "@blitzjs/rpc";';
    let code = blitzImport + src;
    code += "\n\n";
    for (let resolverFilePath of resolvers) {
      const routePath = convertPageFilePathToRoutePath({
        appRoot: root,
        absoluteFilePath: resolverFilePath,
        resolverBasePath: options == null ? void 0 : options.resolverPath,
        extraRpcBasePaths: options == null ? void 0 : options.includeRPCFolders
      });
      code += `__internal_addBlitzRpcResolver('${routePath}',() => import('${slash(
        resolverFilePath
      )}'));`;
      code += "\n";
    }
    return code;
  });
}
function collectResolvers(directory, rpcFolders, pageExtensions) {
  return recursiveFindResolvers(
    directory,
    buildPageExtensionRegex(pageExtensions),
    void 0,
    [],
    directory,
    rpcFolders
  );
}
function recursiveFindResolvers(_0, _1, _2) {
  return __async(this, arguments, function* (dir, filter, ignore, arr = [], rootDir = dir, rpcFolders = []) {
    let folders = yield promises.readdir(dir);
    if (dir === rootDir) {
      folders = folders.filter((folder) => topLevelFoldersThatMayContainResolvers.includes(folder));
      folders.push(...rpcFolders);
    }
    yield Promise.all(
      folders.map((part) => __async(this, null, function* () {
        const absolutePath = join(dir, part);
        if (ignore && ignore.test(part))
          return;
        const pathStat = yield promises.stat(absolutePath);
        if (pathStat.isDirectory()) {
          if (!absolutePath.includes("node_modules")) {
            yield recursiveFindResolvers(absolutePath, filter, ignore, arr, rootDir);
            return;
          }
        }
        if (!filter.test(part)) {
          return;
        }
        if (getIsRpcFile(absolutePath)) {
          arr.push(absolutePath);
          return;
        }
      }))
    );
    return arr.sort();
  });
}

export { collectResolvers, loader, recursiveFindResolvers, transformBlitzRpcServer };
