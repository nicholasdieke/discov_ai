import * as blitz from 'blitz';
import { AsyncFunc, PromiseReturnType, FirstParam, Ctx } from 'blitz';
import { QueryClient, UseQueryOptions, MutateOptions as MutateOptions$1, UseMutationOptions, UseQueryResult, UseInfiniteQueryResult, UseInfiniteQueryOptions, UseMutationResult, DefaultOptions } from '@tanstack/react-query';
export { QueryClient, QueryClientProvider, dehydrate, useQueryErrorResetBoundary } from '@tanstack/react-query';

declare global {
    var queryClient: QueryClient;
    var __BLITZ_SUSPENSE_ENABLED: boolean;
}

declare function normalizeApiRoute(path: string): string;
declare type ResolverType = "query" | "mutation";
interface BuildRpcClientParams {
    resolverName: string;
    resolverType: ResolverType;
    routePath: string;
    httpMethod: string;
}
interface RpcOptions {
    fromQueryHook?: boolean;
    fromInvoke?: boolean;
    alreadySerialized?: boolean;
}
interface EnhancedRpc {
    _isRpcClient: true;
    _resolverType: ResolverType;
    _resolverName: string;
    _routePath: string;
}
interface RpcClientBase<Input = unknown, Result = unknown> {
    (params: Input, opts?: RpcOptions, signal?: AbortSignal): Promise<Result>;
}
interface RpcClient<Input = unknown, Result = unknown> extends EnhancedRpc, RpcClientBase<Input, Result> {
}
declare function __internal_buildRpcClient({ resolverName, resolverType, routePath, httpMethod, }: BuildRpcClientParams): RpcClient;

declare type Resolver<TInput, TResult> = (input: TInput, ctx?: any) => Promise<TResult>;
declare type MutateOptions = {
    refetch?: boolean;
};
declare const getQueryClient: () => QueryClient;
interface QueryCacheFunctions<T> {
    setQueryData: (newData: T | ((oldData: T | undefined) => T), opts?: MutateOptions) => ReturnType<typeof setQueryData>;
}
declare type BlitzQueryKey = [string] | [string, any];
declare function getQueryKey<TInput, TResult, T extends AsyncFunc>(resolver: T | Resolver<TInput, TResult> | RpcClient<TInput, TResult>, ...params: [TInput] | []): BlitzQueryKey;
declare function getInfiniteQueryKey<TInput, TResult, T extends AsyncFunc>(resolver: T | Resolver<TInput, TResult> | RpcClient<TInput, TResult>, params?: TInput): any[];
interface InvalidateQuery {
    <TInput, TResult, T extends AsyncFunc>(resolver: T | Resolver<TInput, TResult> | RpcClient<TInput, TResult>, ...params: [TInput]): Promise<void>;
    <TInput, TResult, T extends AsyncFunc>(resolver: T | Resolver<TInput, TResult> | RpcClient<TInput, TResult>): Promise<void>;
    (): Promise<void>;
}
declare const invalidateQuery: InvalidateQuery;
declare function setQueryData<TInput, TResult, T extends AsyncFunc>(resolver: T | Resolver<TInput, TResult> | RpcClient<TInput, TResult>, params: TInput, newData: TResult | ((oldData: TResult | undefined) => TResult | undefined), opts?: MutateOptions): Promise<void | ReturnType<ReturnType<typeof getQueryClient>["invalidateQueries"]>>;
declare function getQueryData<TInput, TResult, T extends AsyncFunc>(resolver: T | Resolver<TInput, TResult> | RpcClient<TInput, TResult>, params: TInput): TResult | undefined;

declare type QueryLazyOptions = {
    suspense: unknown;
} | {
    enabled: unknown;
};
declare type QueryNonLazyOptions = {
    suspense: true;
    enabled?: never;
} | {
    suspense?: never;
    enabled: true;
} | {
    suspense: true;
    enabled: true;
} | {
    suspense?: never;
    enabled?: never;
};
declare type RestQueryResult<TResult, TError> = Omit<UseQueryResult<TResult, TError>, "data"> & QueryCacheFunctions<TResult>;
declare function useQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options?: UseQueryOptions<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData, RestQueryResult<TSelectedData, TError>];
declare function useQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData | undefined, RestQueryResult<TSelectedData, TError>];
declare type RestPaginatedResult<TResult, TError> = Omit<UseQueryResult<TResult, TError>, "data"> & QueryCacheFunctions<TResult>;
declare function usePaginatedQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options?: UseQueryOptions<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData, RestPaginatedResult<TSelectedData, TError>];
declare function usePaginatedQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, params: FirstParam<T>, options: UseQueryOptions<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData | undefined, RestPaginatedResult<TSelectedData, TError>];
interface RestInfiniteResult<TResult, TError> extends Omit<UseInfiniteQueryResult<TResult, TError>, "data">, QueryCacheFunctions<TResult> {
    pageParams: any;
}
interface InfiniteQueryConfig<TResult, TError, TSelectedData> extends UseInfiniteQueryOptions<TResult, TError, TSelectedData, TResult> {
}
declare function useInfiniteQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, getQueryParams: (pageParam: any) => FirstParam<T>, options: InfiniteQueryConfig<TResult, TError, TSelectedData> & QueryNonLazyOptions): [TSelectedData[], RestInfiniteResult<TSelectedData, TError>];
declare function useInfiniteQuery<T extends AsyncFunc, TResult = PromiseReturnType<T>, TError = unknown, TSelectedData = TResult>(queryFn: T, getQueryParams: (pageParam: any) => FirstParam<T>, options: InfiniteQueryConfig<TResult, TError, TSelectedData> & QueryLazyOptions): [TSelectedData[] | undefined, RestInfiniteResult<TSelectedData, TError>];
declare type MutateFunction<TData, TError = unknown, TVariables = unknown, TContext = unknown> = (variables?: TVariables, config?: MutateOptions$1<TData, TError, TVariables, TContext>) => Promise<TData>;
declare type MutationResultPair<TData, TError, TVariables, TContext> = [
    MutateFunction<TData, TError, TVariables, TContext>,
    Omit<UseMutationResult<TData, TError>, "mutate" | "mutateAsync">
];
declare type MutationFunction<TData, TVariables = unknown> = (variables: TVariables, ctx?: any) => Promise<TData>;
declare function useMutation<TData = unknown, TError = unknown, TVariables = void, TContext = unknown>(mutationResolver: MutationFunction<TData, TVariables>, config?: UseMutationOptions<TData, TError, TVariables, TContext>): MutationResultPair<TData, TError, TVariables, TContext>;

declare function invoke<T extends (...args: any) => any, TInput = FirstParam<T>>(queryFn: T, params: TInput): Promise<PromiseReturnType<T>>;

declare function invokeWithCtx<T extends (...args: any) => any, TInput = FirstParam<T>>(queryFn: T, params: TInput, ctx: Ctx): Promise<PromiseReturnType<T>>;

interface BlitzRpcOptions {
    reactQueryOptions?: DefaultOptions;
}
declare const BlitzRpcPlugin: (options: BlitzRpcOptions) => blitz.ClientPlugin<{
    queryClient: QueryClient;
}>;

export { BlitzRpcPlugin, BuildRpcClientParams, EnhancedRpc, MutateFunction, ResolverType, RpcClient, RpcClientBase, RpcOptions, __internal_buildRpcClient, getInfiniteQueryKey, getQueryClient, getQueryData, getQueryKey, invalidateQuery, invoke, invokeWithCtx, normalizeApiRoute, setQueryData, useInfiniteQuery, useMutation, usePaginatedQuery, useQuery };
