import { Ctx, EnsurePromise, AuthenticatedMiddlewareCtx, Await, ResolverConfig } from 'blitz';
import { NextApiRequest, NextApiResponse } from 'next';
export { BlitzRpcPlugin, BuildRpcClientParams, EnhancedRpc, MutateFunction, ResolverType, RpcClient, RpcClientBase, RpcOptions, __internal_buildRpcClient, getInfiniteQueryKey, getQueryClient, getQueryData, getQueryKey, invalidateQuery, invoke, invokeWithCtx, normalizeApiRoute, setQueryData, useInfiniteQuery, useMutation, usePaginatedQuery, useQuery } from './index-browser.js';
import { SessionContextBase } from '@blitzjs/auth';
import { ZodTypeAny, input, output } from 'zod';
export { QueryClient, QueryClientProvider, dehydrate, useQueryErrorResetBoundary } from '@tanstack/react-query';

declare type ParserType = "sync" | "async";
interface ResultWithContext<Result = unknown, Context = unknown> {
    __blitz: true;
    value: Result;
    ctx: Context;
}
declare type PipeFn<Prev, Next, PrevCtx, NextCtx = PrevCtx> = (i: Await<Prev>, c: PrevCtx) => Next extends ResultWithContext ? never : Next | ResultWithContext<Next, NextCtx>;
declare function pipe<A, Z>(ab: (i: A, c: Ctx) => Z): (input: A, ctx: Ctx) => EnsurePromise<Z>;
declare function pipe<A, B, C, CA = Ctx, CB = CA, CC = CB>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>): (input: A, ctx: CA) => EnsurePromise<C>;
declare function pipe<A, B, C, D, CA = Ctx, CB = CA, CC = CB, CD = CC>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>): (input: A, ctx: CA) => EnsurePromise<D>;
declare function pipe<A, B, C, D, E, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>): (input: A, ctx: CA) => EnsurePromise<E>;
declare function pipe<A, B, C, D, E, F, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>): (input: A, ctx: CA) => EnsurePromise<F>;
declare function pipe<A, B, C, D, E, F, G, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE, CG = CF>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>, fg: PipeFn<F, G, CF, CG>): (input: A, ctx: CA) => EnsurePromise<G>;
declare function pipe<A, B, C, D, E, F, G, H, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE, CG = CF, CH = CG>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>, fg: PipeFn<F, G, CF, CG>, gh: PipeFn<G, H, CG, CH>): (input: A, ctx: CA) => EnsurePromise<H>;
declare function pipe<A, B, C, D, E, F, G, H, I, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE, CG = CF, CH = CG, CI = CH>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>, fg: PipeFn<F, G, CF, CG>, gh: PipeFn<G, H, CG, CH>, hi: PipeFn<H, I, CH, CI>): (input: A, ctx: CA) => EnsurePromise<I>;
declare function pipe<A, B, C, D, E, F, G, H, I, J, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE, CG = CF, CH = CG, CI = CH, CJ = CI>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>, fg: PipeFn<F, G, CF, CG>, gh: PipeFn<G, H, CG, CH>, hi: PipeFn<H, I, CH, CI>, ij: PipeFn<I, J, CI, CJ>): (input: A, ctx: CA) => EnsurePromise<J>;
declare function pipe<A, B, C, D, E, F, G, H, I, J, K, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE, CG = CF, CH = CG, CI = CH, CJ = CI, CK = CJ>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>, fg: PipeFn<F, G, CF, CG>, gh: PipeFn<G, H, CG, CH>, hi: PipeFn<H, I, CH, CI>, ij: PipeFn<I, J, CI, CJ>, jk: PipeFn<J, K, CJ, CK>): (input: A, ctx: CA) => EnsurePromise<K>;
declare function pipe<A, B, C, D, E, F, G, H, I, J, K, L, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE, CG = CF, CH = CG, CI = CH, CJ = CI, CK = CJ, CL = CK>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>, fg: PipeFn<F, G, CF, CG>, gh: PipeFn<G, H, CG, CH>, hi: PipeFn<H, I, CH, CI>, ij: PipeFn<I, J, CI, CJ>, jk: PipeFn<J, K, CJ, CK>, kl: PipeFn<K, L, CK, CL>): (input: A, ctx: CA) => EnsurePromise<L>;
declare function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, CA = Ctx, CB = CA, CC = CB, CD = CC, CE = CD, CF = CE, CG = CF, CH = CG, CI = CH, CJ = CI, CK = CJ, CL = CK, CM = CL>(ab: PipeFn<A, B, CA, CB>, bc: PipeFn<B, C, CB, CC>, cd: PipeFn<C, D, CC, CD>, de: PipeFn<D, E, CD, CE>, ef: PipeFn<E, F, CE, CF>, fg: PipeFn<F, G, CF, CG>, gh: PipeFn<G, H, CG, CH>, hi: PipeFn<H, I, CH, CI>, ij: PipeFn<I, J, CI, CJ>, jk: PipeFn<J, K, CJ, CK>, kl: PipeFn<K, L, CK, CL>, lm: PipeFn<L, M, CL, CM>): (input: A, ctx: CA) => EnsurePromise<M>;
interface ResolverAuthorize {
    <T, C = Ctx>(...args: Parameters<SessionContextBase["$authorize"]>): (input: T, ctx: C) => ResultWithContext<T, AuthenticatedMiddlewareCtx>;
}
declare function zod<Schema extends ZodTypeAny, InputType = input<Schema>, OutputType = output<Schema>>(schema: Schema, parserType: "sync"): (input: InputType) => OutputType;
declare function zod<Schema extends ZodTypeAny, InputType = input<Schema>, OutputType = output<Schema>>(schema: Schema, parserType: "async"): (input: InputType) => Promise<OutputType>;
declare function zod<Schema extends ZodTypeAny, InputType = input<Schema>, OutputType = output<Schema>>(schema: Schema): (input: InputType) => Promise<OutputType>;
declare const resolver: {
    pipe: typeof pipe;
    zod: typeof zod;
    authorize: ResolverAuthorize;
};

declare type Resolver = (...args: unknown[]) => Promise<unknown>;
declare type ResolverFiles = Record<string, () => Promise<{
    default?: Resolver;
    config?: ResolverConfig;
}>>;
declare type ResolverPathOptions = "queries|mutations" | "root" | ((path: string) => string);
declare function loadBlitzRpcResolverFilesWithInternalMechanism(): ResolverFiles | null;
declare function __internal_addBlitzRpcResolver(routePath: string, resolver: () => Promise<{
    default?: Resolver;
    config?: ResolverConfig;
}>): () => Promise<{
    default?: Resolver;
    config?: ResolverConfig;
}>;
interface WebpackRuleOptions {
    resolverPath: ResolverPathOptions | undefined;
    includeRPCFolders: string[] | undefined;
}
interface WebpackRule {
    test: RegExp;
    use: Array<{
        loader: string;
        options: WebpackRuleOptions;
    }>;
}
interface InstallWebpackConfigOptions {
    webpackConfig: {
        resolve: {
            alias: {
                [key: string]: boolean;
            };
        };
        module: {
            rules: WebpackRule[];
        };
    };
    webpackRuleOptions: WebpackRuleOptions;
}
declare function installWebpackConfig({ webpackConfig, webpackRuleOptions, }: InstallWebpackConfigOptions): void;
interface RpcConfig {
    onError?: (error: Error) => void;
}
declare function rpcHandler(config: RpcConfig): (req: NextApiRequest, res: NextApiResponse, ctx: Ctx) => Promise<void>;

export { InstallWebpackConfigOptions, ParserType, ResolverPathOptions, __internal_addBlitzRpcResolver, installWebpackConfig, loadBlitzRpcResolverFilesWithInternalMechanism, resolver, rpcHandler };
