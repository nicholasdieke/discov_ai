import * as blitz from 'blitz';
import { ClientPlugin, Ctx } from 'blitz';
import { QueryClient, HydrateOptions } from '@tanstack/react-query';
import * as React from 'react';
import React__default, { ReactNode } from 'react';
import { UrlObject } from 'url';
import { AppPropsType } from 'next/dist/shared/lib/utils';
import * as next_router from 'next/router';
import { NextRouter, Router } from 'next/router';
import { NextPageContext } from 'next';
import { ParsedUrlQuery } from 'querystring';
export { Routes } from '.blitz';

declare type SuperJSONProps<P = any> = P & {
    _superjson?: any;
};

declare global {
    var queryClient: QueryClient;
}

interface ErrorFallbackProps {
    error: Error & Record<any, any>;
    resetErrorBoundary: (...args: Array<unknown>) => void;
}
interface ErrorBoundaryPropsWithComponent {
    onResetKeysChange?: (prevResetKeys: Array<unknown> | undefined, resetKeys: Array<unknown> | undefined) => void;
    onReset?: (...args: Array<unknown>) => void;
    onError?: (error: Error, info: {
        componentStack: string;
    }) => void;
    resetKeys?: Array<unknown>;
    fallback?: never;
    FallbackComponent: React.ComponentType<ErrorFallbackProps>;
    fallbackRender?: never;
}
declare function FallbackRender(props: ErrorFallbackProps): React.ReactElement<unknown, string | React.FunctionComponent | typeof React.Component> | null;
interface ErrorBoundaryPropsWithRender {
    onResetKeysChange?: (prevResetKeys: Array<unknown> | undefined, resetKeys: Array<unknown> | undefined) => void;
    onReset?: (...args: Array<unknown>) => void;
    onError?: (error: Error, info: {
        componentStack: string;
    }) => void;
    resetKeys?: Array<unknown>;
    fallback?: never;
    FallbackComponent?: never;
    fallbackRender: typeof FallbackRender;
}
interface ErrorBoundaryPropsWithFallback {
    onResetKeysChange?: (prevResetKeys: Array<unknown> | undefined, resetKeys: Array<unknown> | undefined) => void;
    onReset?: (...args: Array<unknown>) => void;
    onError?: (error: Error, info: {
        componentStack: string;
    }) => void;
    resetKeys?: Array<unknown>;
    fallback: React.ReactElement<unknown, string | React.FunctionComponent | typeof React.Component> | null;
    FallbackComponent?: never;
    fallbackRender?: never;
}
declare type ErrorBoundaryProps = ErrorBoundaryPropsWithFallback | ErrorBoundaryPropsWithComponent | ErrorBoundaryPropsWithRender;
declare type ErrorBoundaryState = {
    error: Error | null;
};
declare class ErrorBoundary extends React.Component<React.PropsWithRef<React.PropsWithChildren<ErrorBoundaryProps>>, ErrorBoundaryState> {
    static contextType: React.Context<next_router.NextRouter>;
    static getDerivedStateFromError(error: Error): {
        error: Error;
    };
    state: ErrorBoundaryState;
    updatedWithError: boolean;
    resetErrorBoundary: (...args: Array<unknown>) => void;
    reset(): void;
    componentDidCatch(error: Error, info: React.ErrorInfo): Promise<void>;
    componentDidMount(): void;
    handleRouteChange: () => void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: ErrorBoundaryProps): void;
    render(): string | number | boolean | JSX.Element | React.ReactFragment | null | undefined;
}
declare function withErrorBoundary<P extends JSX.IntrinsicAttributes>(Component: React.ComponentType<P>, errorBoundaryProps: ErrorBoundaryProps): React.ComponentType<P>;
declare function useErrorHandler(givenError?: unknown): (error: unknown) => void;

declare type ErrorProps = {
    statusCode: number;
    title?: string;
};
declare function _getInitialProps({ res, err }: NextPageContext): Promise<ErrorProps> | ErrorProps;
/**
 * `Error` component used for handling errors.
 */
declare class ErrorComponent<P = {}> extends React__default.Component<P & ErrorProps> {
    static displayName: string;
    static getInitialProps: typeof _getInitialProps;
    static origGetInitialProps: typeof _getInitialProps;
    render(): JSX.Element;
}

declare type Dict<T> = Record<string, T | undefined>;
declare type ReturnTypes = "string" | "number" | "array";
declare function extractQueryFromAsPath(asPath: string): Record<string, string | string[]>;
declare function useRouterQuery(): Record<string, string | string[]>;
declare function extractRouterParams(routerQuery: ParsedUrlQuery, asPathQuery: ParsedUrlQuery): {
    [k: string]: string | string[] | undefined;
};
declare function useParams(): Dict<string | string[]>;
declare function useParams(returnType?: ReturnTypes): Dict<string | string[]>;
declare function useParams(returnType: "string"): Dict<string>;
declare function useParams(returnType: "number"): Dict<number>;
declare function useParams(returnType: "array"): Dict<string[]>;
declare function useParam(key: string): undefined | string | string[];
declare function useParam(key: string, returnType: "string"): string | undefined;
declare function useParam(key: string, returnType: "number"): number | undefined;
declare function useParam(key: string, returnType: "array"): string[] | undefined;

declare const RouterContext: React__default.Context<NextRouter>;

declare type BlitzProviderProps = {
    children: JSX.Element;
    client?: QueryClient;
    contextSharing?: boolean;
    dehydratedState?: unknown;
    hydrateOptions?: HydrateOptions;
};
interface RouteUrlObject extends Pick<UrlObject, "pathname" | "query" | "href"> {
    pathname: string;
}
declare type RedirectAuthenticatedTo = string | RouteUrlObject | false;
declare type RedirectAuthenticatedToFnCtx = {
    session: Ctx["session"]["$publicData"];
};
declare type RedirectAuthenticatedToFn = (args: RedirectAuthenticatedToFnCtx) => RedirectAuthenticatedTo;
declare type BlitzPage<P = {}> = React__default.ComponentType<P> & {
    getLayout?: (component: JSX.Element) => JSX.Element;
    authenticate?: boolean | {
        redirectTo?: string | RouteUrlObject;
        role?: string | Array<string>;
    };
    suppressFirstRenderFlicker?: boolean;
    redirectAuthenticatedTo?: RedirectAuthenticatedTo | RedirectAuthenticatedToFn;
};
declare type BlitzLayout<P = {}> = React__default.ComponentType<P & {
    children: ReactNode;
}> & {
    authenticate?: boolean | {
        redirectTo?: string | RouteUrlObject;
    };
    redirectAuthenticatedTo?: RedirectAuthenticatedTo | RedirectAuthenticatedToFn;
};
declare type AppProps<P = {}> = AppPropsType<Router, P> & {
    Component: BlitzPage;
};
declare const BlitzProvider: ({ client, contextSharing, dehydratedState, hydrateOptions, children, }: BlitzProviderProps) => JSX.Element;
declare const setupBlitzClient: <TPlugins extends readonly ClientPlugin<object>[]>({ plugins, }: {
    plugins: TPlugins;
}) => {
    withBlitz: (UserAppRoot: React__default.ComponentType<AppProps>) => React__default.ComponentType<SuperJSONProps<AppProps<{}>>>;
} & blitz.Simplify<blitz.UnionToIntersection<{ [I in keyof TPlugins & number]: ReturnType<TPlugins[I]["exports"]>; }[number]>>;

declare const NoPageFlicker: () => JSX.Element;

export { AppProps, BlitzLayout, BlitzPage, BlitzProvider, BlitzProviderProps, ErrorBoundary, ErrorBoundaryProps, ErrorBoundaryPropsWithComponent, ErrorBoundaryPropsWithFallback, ErrorBoundaryPropsWithRender, ErrorComponent, ErrorFallbackProps, ErrorProps, NoPageFlicker, RouterContext, extractQueryFromAsPath, extractRouterParams, setupBlitzClient, useErrorHandler, useParam, useParams, useRouterQuery, withErrorBoundary };
