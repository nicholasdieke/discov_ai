import { initializeLogger, BlitzLogger, startWatcher, stopWatcher, handleRequestWithMiddleware, isRouteUrlObject } from 'blitz';
import { installWebpackConfig, dehydrate, getInfiniteQueryKey, getQueryKey } from '@blitzjs/rpc';
import { QueryClient } from '@tanstack/react-query';
import { w as withSuperJsonProps } from './chunks/index-browser.mjs';
export { B as BlitzProvider, E as ErrorBoundary, b as ErrorComponent, N as NoPageFlicker, R as RouterContext, e as extractQueryFromAsPath, d as extractRouterParams, s as setupBlitzClient, u as useErrorHandler, g as useParam, f as useParams, c as useRouterQuery, a as withErrorBoundary } from './chunks/index-browser.mjs';
import { resolveHref } from 'next/dist/shared/lib/router/router';
export { Routes } from '.blitz';
import 'next/head';
import 'react';
import 'hoist-non-react-statics';
import 'superjson';
import 'next/router';
import 'debug';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const prefetchQueryFactory = (ctx) => {
  let queryClient = null;
  return {
    getClient: () => queryClient,
    prefetchQuery: (_0, _1, ..._2) => __async(void 0, [_0, _1, ..._2], function* (fn, input, defaultOptions = {}, infinite = false) {
      if (!queryClient) {
        queryClient = new QueryClient({ defaultOptions });
      }
      if (infinite) {
        yield queryClient.prefetchInfiniteQuery(
          getInfiniteQueryKey(fn, input),
          () => fn(input, ctx)
        );
      } else {
        yield queryClient.prefetchQuery(getQueryKey(fn, input), () => fn(input, ctx));
      }
    })
  };
};
const setupBlitzServer = ({ plugins, onError, logger }) => {
  initializeLogger(logger != null ? logger : BlitzLogger());
  const middlewares = plugins.flatMap((p) => p.requestMiddlewares);
  const contextMiddleware = plugins.flatMap((p) => p.contextMiddleware).filter(Boolean);
  const gSSP = (handler) => (_a) => __async(void 0, null, function* () {
    var _b = _a, { req, res } = _b, rest = __objRest(_b, ["req", "res"]);
    yield handleRequestWithMiddleware(req, res, middlewares);
    const ctx = contextMiddleware.reduceRight(
      (y, f) => f ? f(y) : y,
      res.blitzCtx
    );
    const { getClient, prefetchQuery } = prefetchQueryFactory(ctx);
    ctx.prefetchQuery = prefetchQuery;
    ctx.prefetchInfiniteQuery = (fn, input, defaultOptions = {}) => prefetchQuery(fn, input, defaultOptions, true);
    try {
      const result = yield handler(__spreadValues({ req, res, ctx }, rest));
      return withSuperJsonProps(
        withDehydratedState(
          normalizeRedirectValues(result),
          getClient()
        )
      );
    } catch (err) {
      onError == null ? void 0 : onError(err);
      throw err;
    }
  });
  const gSP = (handler) => (context) => __async(void 0, null, function* () {
    const ctx = contextMiddleware.reduceRight((y, f) => f ? f(y) : y, {});
    const { getClient, prefetchQuery } = prefetchQueryFactory(ctx);
    ctx.prefetchQuery = prefetchQuery;
    ctx.prefetchInfiniteQuery = (...args) => prefetchQuery(...args, true);
    try {
      const result = yield handler(__spreadProps(__spreadValues({}, context), { ctx }));
      return withSuperJsonProps(
        withDehydratedState(
          normalizeRedirectValues(result),
          getClient()
        )
      );
    } catch (err) {
      onError == null ? void 0 : onError(err);
      throw err;
    }
  });
  const api = (handler) => (req, res) => __async(void 0, null, function* () {
    try {
      return yield handleRequestWithMiddleware(req, res, [
        ...middlewares,
        (req2, res2) => handler(req2, res2, res2.blitzCtx)
      ]);
    } catch (error) {
      onError == null ? void 0 : onError(error);
      return res.status(400).send(error);
    }
  });
  return { gSSP, gSP, api };
};
function withBlitz(nextConfig = {}) {
  if (process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && process.env.MODE !== "test") {
    void startWatcher();
    process.on("SIGINT", () => {
      void stopWatcher();
      process.exit(0);
    });
    process.on("exit", function() {
      void stopWatcher();
    });
  }
  const config = Object.assign({}, nextConfig, {
    webpack: (config2, options) => {
      var _a2, _b;
      installWebpackConfig({
        webpackConfig: config2,
        webpackRuleOptions: {
          resolverPath: (_a2 = nextConfig.blitz) == null ? void 0 : _a2.resolverPath,
          includeRPCFolders: (_b = nextConfig.blitz) == null ? void 0 : _b.includeRPCFolders
        }
      });
      if (typeof nextConfig.webpack === "function") {
        return nextConfig.webpack(config2, options);
      }
      return config2;
    }
  });
  const _a = config, rest = __objRest(_a, ["blitz"]);
  return rest;
}
function withDehydratedState(result, queryClient) {
  if (!queryClient) {
    return result;
  }
  const dehydratedState = dehydrate(queryClient);
  return __spreadProps(__spreadValues({}, result), { props: __spreadProps(__spreadValues({}, "props" in result ? result.props : void 0), { dehydratedState }) });
}
const normalizeRedirectValues = (result) => {
  var _a;
  if ("redirect" in result) {
    const dest = (_a = result.redirect) == null ? void 0 : _a.destination;
    if (dest && isRouteUrlObject(dest)) {
      const resolvedDest = resolveHref({ asPath: "/", pathname: "/" }, dest, true);
      return __spreadProps(__spreadValues({}, result), {
        redirect: __spreadProps(__spreadValues({}, result.redirect), { destination: resolvedDest[1] || resolvedDest[0] })
      });
    }
  }
  return result;
};

export { setupBlitzServer, withBlitz };
