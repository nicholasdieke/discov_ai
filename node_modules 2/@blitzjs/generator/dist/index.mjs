import spawn, { spawn as spawn$1 } from 'cross-spawn';
import chalk from 'chalk';
import * as fs from 'fs-extra';
import { readJSONSync, writeJson } from 'fs-extra';
import * as path from 'path';
import path__default, { join } from 'path';
import username from 'username';
import * as babel from '@babel/core';
import babelTransformTypescript from '@babel/plugin-transform-typescript';
import enquirer from 'enquirer';
import { EventEmitter } from 'events';
import j from 'jscodeshift';
import { create } from 'mem-fs';
import { create as create$1 } from 'mem-fs-editor';
import getBabelOptions from 'recast/parsers/_babel_options';
import * as babelParser from 'recast/parsers/babel';
import { diffLines } from 'diff';
import { Transform } from 'stream';
import fs$1, { promises } from 'fs';
import prettier from 'prettier';
import { Logger } from 'tslog';
import { Table } from 'console-table-printer';
import ora from 'ora';
import readline from 'readline';
import os from 'os';
import got from 'got';
import * as ast from '@mrleebo/prisma-ast';
import which from 'npm-which';
import pluralize from 'pluralize';

class PromptAbortedError extends Error {
  constructor() {
    super("Prompt aborted");
  }
}

var __async$e = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class ConflictChecker extends Transform {
  constructor(options) {
    super({
      objectMode: true
    });
    this.options = options;
    this._destroyed = false;
    this.options = options;
  }
  _transform(file, _encoding, cb) {
    if (file.state === null) {
      cb();
      return;
    }
    const filePath = path.resolve(file.path);
    if (!fs.existsSync(filePath)) {
      this.handlePush(file, "create");
      cb();
      return;
    }
    this.checkDiff(file).then((status) => {
      var _a;
      if (status !== "skip") {
        this.handlePush(file, status);
      } else {
        this.fileStatusString(file, status, (_a = this.options) == null ? void 0 : _a.dryRun);
      }
      cb();
    }).catch((err) => {
      cb(err || new PromptAbortedError());
    });
  }
  destroy(err) {
    if (this._destroyed)
      return this;
    this._destroyed = true;
    process.nextTick(() => {
      if (err)
        this.emit("err", err);
      this.emit("close");
    });
    return this;
  }
  handlePush(file, status) {
    var _a, _b;
    if (!((_a = this.options) == null ? void 0 : _a.dryRun))
      this.push(file);
    this.emit("fileStatus", this.fileStatusString(file, status, (_b = this.options) == null ? void 0 : _b.dryRun));
  }
  checkDiff(file) {
    return __async$e(this, null, function* () {
      var _a, _b;
      let newFileContents = (_b = (_a = file.contents) == null ? void 0 : _a.toString()) != null ? _b : "";
      const oldFileContents = fs.readFileSync(path.resolve(file.path)).toString();
      const diff = diffLines(oldFileContents, newFileContents);
      const conflict = diff.some((line) => line.added || line.removed);
      if (conflict) {
        let answer = null;
        do {
          answer = yield enquirer.prompt({
            type: "select",
            name: "action",
            message: `The file "${file.path}" has conflicts. What do you want to do?`,
            choices: [
              { name: "overwrite", message: "Overwrite", value: "overwrite" },
              { name: "skip", message: "Skip", value: "skip" },
              { name: "show", message: "Show changes", value: "show" }
            ]
          });
          if ((answer == null ? void 0 : answer.action) === "show")
            this.printDiff(diff);
        } while ((answer == null ? void 0 : answer.action) === "show");
        return answer.action;
      }
      return "identical";
    });
  }
  printDiff(diff) {
    console.log("\n");
    diff.forEach((line) => {
      const value = line.value.replace("\n", "");
      if (line.added) {
        console.log(chalk.green(`+ ${value}`));
      } else if (line.removed) {
        console.log(chalk.red(`- ${value}`));
      } else {
        console.log(value);
      }
    });
    console.log("\n");
  }
  fileStatusString(file, status, dryRun = false) {
    let statusLog = null;
    switch (status) {
      case "create":
        statusLog = chalk.green(`${dryRun ? "Would create" : "CREATE"}   `);
        break;
      case "overwrite":
        statusLog = chalk.cyan(`${dryRun ? "Would overwrite" : "OVERWRITE"}   `);
        break;
      case "skip":
        statusLog = chalk.blue("SKIP     ");
        break;
      case "identical":
        statusLog = chalk.gray("IDENTICAL");
    }
    return `${statusLog} ${file.relative}`;
  }
}

function pipe(...fns) {
  return function piper(initial, ...args) {
    return fns.reduce((acc, val) => val(acc, ...args), initial);
  };
}

var __async$d = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function readdirRecursive(root, filter, dir = "") {
  return __async$d(this, null, function* () {
    const absoluteDir = path__default.resolve(root, dir);
    const dirStats = yield promises.stat(absoluteDir);
    if (dirStats.isDirectory()) {
      let entries = yield promises.readdir(absoluteDir);
      if (filter) {
        entries = entries.filter((name) => filter(name, dir));
      }
      const recursiveList = yield Promise.all(
        entries.map((name) => readdirRecursive(root, filter, path__default.join(dir, name)))
      );
      return recursiveList.flat(Infinity);
    } else {
      return [dir];
    }
  });
}

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async$c = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const debug$1 = require("debug")("blitz:generator");
function getProjectRootSync() {
  return path.dirname(getConfigSrcPath());
}
function getConfigSrcPath() {
  const jsPath = path.resolve(path.join(process.cwd(), "next.config.js"));
  return jsPath;
}
const customTemplatesBlitzConfig = (isTypeScript, customTemplatesPath = "", codemod = false) => __async$c(void 0, null, function* () {
  var _a;
  const { globby } = yield import('globby');
  const blitzServer = yield globby(["{app,src}/**/blitz-server.{ts,js}"], {
    cwd: getProjectRootSync()
  });
  if (blitzServer.length === 0) {
    throw new Error("Could not find blitz-server.js or blitz-server.ts in app or src folder");
  }
  if (blitzServer.length > 1) {
    throw new Error("Found more than one blitz-server.js or blitz-server.ts in app or src folder");
  }
  const blitzServerPath = require("path").join(process.cwd(), blitzServer.at(0));
  const userConfigModuleSource = fs.readFileSync(blitzServerPath, { encoding: "utf-8" });
  const userConfigModule = j(userConfigModuleSource, { parser: customTsParser });
  const program = userConfigModule.get();
  const cliConfigDeclaration = userConfigModule.find(j.ExportNamedDeclaration, {
    declaration: {
      type: "VariableDeclaration",
      declarations: [
        {
          id: {
            name: "cliConfig"
          }
        }
      ]
    }
  }).paths().at(0);
  if (!cliConfigDeclaration) {
    const config = j.identifier("cliConfig");
    const configVariable = j.variableDeclaration("const", [
      j.variableDeclarator(
        config,
        j.objectExpression([
          j.objectProperty(j.identifier("customTemplates"), j.literal(customTemplatesPath))
        ])
      )
    ]);
    if (isTypeScript) {
      const type = j.tsTypeAnnotation(j.tsTypeReference(j.identifier("BlitzCliConfig")));
      const declaration = configVariable == null ? void 0 : configVariable.declarations;
      declaration[0].id.typeAnnotation = type;
      const typeImport = j.importDeclaration(
        [j.importSpecifier(j.identifier("BlitzCliConfig"))],
        j.literal("blitz")
      );
      typeImport.importKind = "type";
      program.node.program.body.unshift(typeImport);
    }
    const exportConfig = j.exportNamedDeclaration(configVariable);
    program.node.program.body.push(exportConfig);
  } else {
    const configType = (_a = cliConfigDeclaration.value.declaration) == null ? void 0 : _a.type;
    if (configType === "VariableDeclaration") {
      const config = cliConfigDeclaration.value.declaration.declarations[0];
      if ((config == null ? void 0 : config.type) === "VariableDeclarator") {
        const configProperties = config.init;
        if ((configProperties == null ? void 0 : configProperties.type) === "ObjectExpression") {
          const customTemplatesProperty = configProperties.properties.find((property) => {
            if (property.type === "ObjectProperty") {
              const key = property.key;
              if (key.type === "Identifier") {
                return key.name === "customTemplates";
              }
            }
          });
          if (!customTemplatesProperty) {
            configProperties.properties.push(
              j.objectProperty(j.identifier("customTemplates"), j.literal(customTemplatesPath))
            );
          } else {
            if (customTemplatesProperty.type === "ObjectProperty") {
              const customValue = customTemplatesProperty.value;
              if (customValue.type === "StringLiteral") {
                if (!codemod) {
                  return customValue.value;
                }
                customValue.value = customTemplatesPath;
              }
            }
          }
        }
      }
    }
  }
  if (codemod) {
    const newSource = userConfigModule.toSource();
    fs.writeFileSync(blitzServerPath, newSource);
  }
});
const customTsParser = {
  parse(source, options) {
    const babelOptions = getBabelOptions(options);
    babelOptions.plugins.push("typescript");
    babelOptions.plugins.push("jsx");
    return babelParser.parser.parse(source, babelOptions);
  }
};
const alwaysIgnoreFiles = [".blitz", ".DS_Store", ".git", ".next", ".now", "node_modules"];
const ignoredExtensions = [".ico", ".png", ".jpg"];
const tsExtension = /\.(tsx?|ts?)$/;
const codeFileExtensions = /\.(tsx?|jsx?)$/;
function getStatements(node) {
  return j.BlockStatement.check(node) ? node.body : [node];
}
function replaceConditionalNode(path2, templateValues) {
  const condition = path2.node.test.property.name;
  if (!Object.keys(templateValues).includes(condition))
    return;
  const derivedCondition = templateValues[condition];
  if (derivedCondition) {
    j(path2).replaceWith(getStatements(path2.node.consequent));
  } else {
    if (path2.node.alternate) {
      j(path2).replaceWith(getStatements(path2.node.alternate));
    } else {
      j(path2).remove();
    }
  }
}
function replaceConditionalStatements(program, templateValues) {
  const processEnvRequirements = {
    test: {
      object: {
        object: { name: "process" },
        property: { name: "env" }
      }
    }
  };
  program.find(j.IfStatement, processEnvRequirements).forEach((path2) => replaceConditionalNode(path2, templateValues));
  program.find(j.ConditionalExpression, processEnvRequirements).forEach((path2) => replaceConditionalNode(path2, templateValues));
  return program;
}
function replaceJsxConditionals(program, templateValues) {
  program.find(j.JSXIdentifier, { name: "if" }).forEach((path2) => {
    var _a, _b;
    if (j.JSXOpeningElement.check(path2.parent.node)) {
      const conditionPath = j(path2.parent).find(j.JSXAttribute, { name: { name: "condition" } }).at(0);
      const condition = ((_a = conditionPath.paths()[0]) == null ? void 0 : _a.value.value).value;
      if (!Object.keys(templateValues).includes(condition))
        return;
      const useConsequent = templateValues[condition];
      const innerElements = path2.parent.parent.node.children.filter(
        j.JSXElement.check.bind(j.JSXElement)
      );
      const consequent = innerElements[0];
      const alternate = innerElements[1] && ((_b = j(innerElements[1]).paths()[0]) == null ? void 0 : _b.node.children.filter(j.JSXElement.check.bind(j.JSXElement)));
      const result = useConsequent ? consequent : alternate;
      if (!result) {
        j(path2.parent.parent).remove();
      } else {
        j(path2.parent.parent).replaceWith(result);
      }
    }
  });
  return program;
}
class Generator extends EventEmitter {
  constructor(options) {
    super();
    this.options = options;
    this.performedActions = [];
    this.prettierDisabled = false;
    this.unsafe_disableConflictChecker = false;
    this.returnResults = false;
    this.options = options;
    this.store = create();
    this.fs = create$1(this.store);
    this.enquirer = new enquirer();
    this.prettier = prettier;
    this.useTs = typeof this.options.useTs === "undefined" ? fs.existsSync(path.resolve("tsconfig.json")) : this.options.useTs;
    if (!this.options.destinationRoot)
      this.options.destinationRoot = process.cwd();
  }
  filesToIgnore() {
    return [];
  }
  replaceConditionals(input, templateValues, prettierOptions = {}) {
    const source = j(input, { parser: customTsParser });
    const program = source.find(j.Program);
    const result = pipe(replaceConditionalStatements, replaceJsxConditionals)(
      program,
      templateValues
    );
    return result.toSource(__spreadProps(__spreadValues$1({}, prettierOptions), { lineTerminator: "\n" }));
  }
  replaceTemplateValues(input, templateValues) {
    let result = input;
    for (let templateKey in templateValues) {
      const token = `__${templateKey}__`;
      if (result.includes(token)) {
        result = result.replace(new RegExp(token, "g"), templateValues[templateKey]);
      }
    }
    return result;
  }
  process(input, pathEnding, templateValues, prettierOptions) {
    var _a;
    debug$1("Generator.process...");
    if (new RegExp(`${ignoredExtensions.join("|")}$`).test(pathEnding)) {
      return input;
    }
    const inputStr = input.toString("utf-8");
    let templatedFile = inputStr;
    if (codeFileExtensions.test(pathEnding)) {
      templatedFile = this.replaceConditionals(inputStr, templateValues, prettierOptions || {});
    }
    templatedFile = this.replaceTemplateValues(templatedFile, templateValues);
    if (!this.useTs && tsExtension.test(pathEnding)) {
      templatedFile = ((_a = babel.transform(templatedFile, {
        configFile: false,
        plugins: [[babelTransformTypescript, { isTSX: true }]]
      })) == null ? void 0 : _a.code) || "";
    }
    if (codeFileExtensions.test(pathEnding) && typeof templatedFile === "string" && this.prettier && !this.prettierDisabled) {
      const options = __spreadValues$1({}, prettierOptions);
      if (this.useTs) {
        options.parser = "babel-ts";
      } else {
        options.parser = "babel";
      }
      try {
        templatedFile = this.prettier.format(templatedFile, options);
      } catch (error) {
        console.warn(`Failed trying to run prettier: ` + error);
      }
    }
    return templatedFile;
  }
  write() {
    return __async$c(this, null, function* () {
      var _a;
      debug$1("Generator.write...");
      const sourcePath = this.sourcePath();
      const paths = yield readdirRecursive(sourcePath, (name) => {
        const additionalFilesToIgnore = this.filesToIgnore();
        return ![...alwaysIgnoreFiles, ...additionalFilesToIgnore].includes(name);
      });
      const prettierOptions = yield (_a = this.prettier) == null ? void 0 : _a.resolveConfig(sourcePath);
      for (let filePath of paths) {
        try {
          let pathSuffix = filePath;
          pathSuffix = path.join(this.getTargetDirectory(), pathSuffix);
          const templateValues = yield this.getTemplateValues();
          let templatedPathSuffix = this.replaceTemplateValues(pathSuffix, templateValues);
          const newContent = this.process(
            this.fs.read(this.sourcePath(filePath), { raw: true }),
            pathSuffix,
            templateValues,
            prettierOptions != null ? prettierOptions : void 0
          );
          this.fs.write(this.destinationPath(pathSuffix), newContent);
          if (!this.useTs && tsExtension.test(this.destinationPath(pathSuffix))) {
            templatedPathSuffix = templatedPathSuffix.replace(tsExtension, ".js");
          }
          if (templatedPathSuffix !== pathSuffix) {
            this.fs.move(this.destinationPath(pathSuffix), this.destinationPath(templatedPathSuffix));
          }
        } catch (error) {
          console.error(`Error generating ${filePath}`);
          throw error;
        }
      }
    });
  }
  preCommit() {
    return __async$c(this, null, function* () {
    });
  }
  postWrite() {
    return __async$c(this, null, function* () {
    });
  }
  preventFileFromLogging(_path) {
    return false;
  }
  sourcePath(...paths) {
    if (this.sourceRoot.type === "absolute") {
      return path.join(this.sourceRoot.path, ...paths);
    } else {
      return path.join(
        __dirname,
        "..",
        process.env.NODE_ENV === "test" ? "./templates" : "./dist/templates",
        this.sourceRoot.path,
        ...paths
      );
    }
  }
  destinationPath(...paths) {
    return path.join(this.options.destinationRoot, ...paths);
  }
  run() {
    return __async$c(this, null, function* () {
      debug$1("Generator.run...", { options: this.options });
      if (!this.options.dryRun) {
        yield fs.ensureDir(this.options.destinationRoot);
        process.chdir(this.options.destinationRoot);
      }
      yield this.write();
      yield this.preCommit();
      if (this.unsafe_disableConflictChecker) {
        yield new Promise((resolve, reject) => {
          try {
            this.fs.commit(resolve);
          } catch (err) {
            reject(err);
          }
        });
      } else {
        yield new Promise((resolve, reject) => {
          const conflictChecker = new ConflictChecker({
            dryRun: this.options.dryRun
          });
          conflictChecker.on("error", (err) => {
            reject(err);
          });
          conflictChecker.on("fileStatus", (data) => {
            this.performedActions.push(data);
          });
          this.fs.commit([conflictChecker], (err) => {
            if (err)
              reject(err);
            resolve();
          });
        });
      }
      if (!this.returnResults) {
        this.performedActions.sort().filter((action) => {
          const path2 = action.split(/ +/g).pop();
          return !this.preventFileFromLogging(path2);
        }).forEach((action) => console.log(action));
      }
      if (!this.options.dryRun) {
        yield this.postWrite();
      }
      if (this.returnResults) {
        return this.performedActions.join("\n");
      }
    });
  }
}

const imageConfigDefault = {
  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  path: "/_next/image",
  loader: "default",
  domains: [],
  disableStaticImages: false,
  minimumCacheTTL: 60
};
const defaultConfig = {
  env: {},
  webpack: null,
  webpackDevMiddleware: null,
  distDir: ".next",
  cleanDistDir: true,
  assetPrefix: "",
  configOrigin: "default",
  useFileSystemPublicRoutes: true,
  generateBuildId: () => null,
  generateEtags: true,
  pageExtensions: ["tsx", "ts", "jsx", "js"],
  target: "server",
  poweredByHeader: true,
  compress: true,
  analyticsId: process.env.VERCEL_ANALYTICS_ID || "",
  images: imageConfigDefault,
  devIndicators: {
    buildActivity: true
  },
  onDemandEntries: {
    maxInactiveAge: 60 * 1e3,
    pagesBufferLength: 2
  },
  amp: {
    canonicalBase: ""
  },
  basePath: "",
  sassOptions: {},
  trailingSlash: false,
  i18n: null,
  productionBrowserSourceMaps: false,
  optimizeFonts: true,
  log: {
    level: "info"
  },
  webpack5: Number(process.env.NEXT_PRIVATE_TEST_WEBPACK4_MODE) > 0 ? false : void 0,
  excludeDefaultMomentLocales: true,
  serverRuntimeConfig: {},
  publicRuntimeConfig: {},
  reactStrictMode: false,
  httpAgentOptions: {
    keepAlive: true
  },
  experimental: {
    swcLoader: false,
    swcMinify: false,
    cpus: Math.max(
      1,
      (Number(process.env.CIRCLE_NODE_TOTAL) || (os.cpus() || { length: 1 }).length) - 1
    ),
    plugins: false,
    profiling: false,
    isrFlushToDisk: true,
    workerThreads: false,
    pageEnv: false,
    optimizeImages: false,
    optimizeCss: false,
    scrollRestoration: false,
    stats: false,
    externalDir: false,
    disableOptimizedLoading: false,
    gzipSize: true,
    craCompat: false,
    esmExternals: false,
    staticPageGenerationTimeout: 60,
    pageDataCollectionTimeout: 60,
    isrMemoryCacheSize: 50 * 1024 * 1024,
    concurrentFeatures: false
  },
  future: {
    strictPostcssConfiguration: false
  }
};

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
function normalizeConfig(phase, config) {
  if (typeof config === "function") {
    config = config(phase, { defaultConfig });
    if (typeof config.then === "function") {
      throw new Error(
        "> Promise returned in blitz config. https://nextjs.org/docs/messages/promise-in-next-config"
      );
    }
  }
  return config;
}
function loadConfigAtRuntime() {
  if (!process.env.BLITZ_APP_DIR) {
    throw new Error("Internal Blitz Error: process.env.BLITZ_APP_DIR is not set");
  }
  return loadConfigProduction(process.env.BLITZ_APP_DIR);
}
function assignDefaultsBase(userConfig2) {
  const config = Object.keys(userConfig2).reduce((currentConfig, key) => {
    const value = userConfig2[key];
    if (value === void 0 || value === null) {
      return currentConfig;
    }
    if (!!value && value.constructor === Object) {
      currentConfig[key] = __spreadValues(__spreadValues({}, defaultConfig[key]), Object.keys(value).reduce((c2, k) => {
        const v = value[k];
        if (v !== void 0 && v !== null) {
          c2[k] = v;
        }
        return c2;
      }, {}));
    } else {
      currentConfig[key] = value;
    }
    return currentConfig;
  }, {});
  const result = __spreadValues(__spreadValues({}, defaultConfig), config);
  return result;
}
function loadConfigProduction(pagesDir) {
  let userConfigModule;
  try {
    const path = join(pagesDir, "next.config.js");
    debug("Loading config from ", path);
    userConfigModule = eval("require")(path);
  } catch (e) {
    debug("Did not find custom config file");
    userConfigModule = {};
  }
  let userConfig = normalizeConfig(
    "phase-production-server",
    userConfigModule.default || userConfigModule
  );
  return assignDefaultsBase(userConfig);
}
const baseLogger = (options) => {
  var _a, _b;
  if (globalThis._blitz_baseLogger)
    return globalThis._blitz_baseLogger;
  let config;
  try {
    config = loadConfigAtRuntime();
  } catch (e) {
    config = {};
  }
  globalThis._blitz_baseLogger = new Logger(__spreadValues({
    minLevel: ((_a = config.log) == null ? void 0 : _a.level) || "info",
    type: ((_b = config.log) == null ? void 0 : _b.type) || "pretty",
    dateTimePattern: process.env.NODE_ENV === "production" ? "year-month-day hour:minute:second.millisecond" : "hour:minute:second.millisecond",
    displayFunctionName: false,
    displayFilePath: "hidden",
    displayRequestId: false,
    dateTimeTimezone: process.env.NODE_ENV === "production" ? "utc" : Intl.DateTimeFormat().resolvedOptions().timeZone,
    prettyInspectHighlightStyles: {
      name: "yellow",
      number: "blue",
      bigint: "blue",
      boolean: "blue"
    },
    colorizePrettyLogs: process.env.FORCE_COLOR === "0" ? false : true,
    maskValuesOfKeys: ["password", "passwordConfirmation"],
    exposeErrorCodeFrame: process.env.NODE_ENV !== "production"
  }, options));
  return globalThis._blitz_baseLogger;
};
const blitzBrightBrandColor = "8a3df0";
const brandColor = blitzBrightBrandColor;
const withBrand = (str) => {
  return chalk.hex(brandColor).bold(str);
};
const withCaret = (str) => {
  return `${chalk.gray(">")} ${str}`;
};
const withCheck = (str) => {
  return `${chalk.green("\u2714")} ${str}`;
};
const withProgress = (str) => {
  return withCaret(str);
};
const branded = (msg) => {
  console.log(chalk.hex(brandColor).bold(msg));
};
const clearLine = (msg) => {
  readline.clearLine(process.stdout, 0);
  readline.cursorTo(process.stdout, 0);
  msg && process.stdout.write(msg);
};
const clearConsole = () => {
  if (process.platform === "win32") {
    process.stdout.write("\x1B[2J\x1B[0f");
  } else {
    process.stdout.write("\x1B[2J\x1B[3J\x1B[H");
  }
};
const progress = (msg) => {
  console.log(withProgress(msg));
};
const spinner = (str) => {
  return ora({
    text: str,
    color: "blue",
    spinner: {
      interval: 120,
      frames: ["\u25E2", "\u25E3", "\u25E4", "\u25E5"]
    }
  });
};
const success = (msg) => {
  console.log(withCheck(chalk.green(msg)));
};
const variable = (val) => {
  return chalk.cyan.bold(`${val}`);
};
const debug = require("debug")("blitz");
const log = {
  withBrand,
  withCaret,
  branded,
  clearLine,
  clearConsole,
  progress,
  spinner,
  success,
  variable,
  debug,
  Table
};

var __async$b = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const fetchAllVersions = (dependency) => __async$b(void 0, null, function* () {
  const res = yield got(`https://registry.npmjs.org/${dependency}`, {
    retry: { limit: 3 },
    timeout: 3e3,
    responseType: "json"
  }).json();
  return Object.keys(res.versions);
});
const fetchDistTags = (dependency) => __async$b(void 0, null, function* () {
  const res = yield got(`https://registry.npmjs.org/-/package/${dependency}/dist-tags`, {
    retry: { limit: 3 },
    timeout: 3e3,
    responseType: "json"
  }).json();
  return res;
});
const fetchLatestDistVersion = (dependency) => __async$b(void 0, null, function* () {
  const res = yield fetchDistTags(dependency);
  return res.latest;
});

var __async$a = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const logFailedVersionFetch = (dependency, fallback) => {
  console.warn(
    `Failed to fetch latest version of '${chalk.bold(dependency)}'`,
    fallback ? `Falling back to '${chalk.bold(fallback)}'` : ""
  );
};
const getLatestVersion = (dependency, templateVersion = "") => __async$a(void 0, null, function* () {
  const major = templateVersion.replace(".x", "");
  try {
    const [allVersions, latestDistVersion] = yield Promise.all([
      fetchAllVersions(dependency),
      fetchLatestDistVersion(dependency)
    ]);
    const latestVersion = allVersions.filter((version) => version.startsWith(major)).sort((a, b) => a.localeCompare(b, void 0, { numeric: true })).reverse()[0] || "";
    if (latestDistVersion.startsWith(major)) {
      return { value: latestDistVersion, isFallback: false };
    } else {
      return { value: latestVersion, isFallback: false };
    }
  } catch (error) {
    const fallback = templateVersion;
    logFailedVersionFetch(dependency, fallback);
    return { value: fallback, isFallback: false };
  }
});

var __async$9 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function fromEntries(entries) {
  return entries.reduce((result, [key, value]) => {
    return Object.assign({}, result, { [key]: value });
  }, {});
}
const fetchLatestVersionsFor = (dependencies) => __async$9(void 0, null, function* () {
  const entries = Object.entries(dependencies || {});
  let fallbackUsed = false;
  const updated = yield Promise.all(
    entries.map((_0) => __async$9(void 0, [_0], function* ([dep, version]) {
      let skipFetch = false;
      if (!version.match(/\d.x/))
        skipFetch = true;
      if (version.match(/experimental/))
        skipFetch = true;
      if (skipFetch) {
        return [dep, version];
      } else {
        const { value: latestVersion, isFallback } = yield getLatestVersion(dep, version);
        if (isFallback) {
          fallbackUsed = true;
        }
        return [dep, latestVersion];
      }
    }))
  );
  return {
    isFallback: fallbackUsed,
    value: fromEntries(updated)
  };
});

var __async$8 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const CURRENT_BLITZ_TAG = "latest";
const getBlitzDependencyVersion = () => __async$8(void 0, null, function* () {
  try {
    const result = yield fetchDistTags("blitz");
    if (CURRENT_BLITZ_TAG in result) {
      return { value: result[CURRENT_BLITZ_TAG] };
    }
    logFailedVersionFetch("blitz");
    return { value: "" };
  } catch (error) {
    logFailedVersionFetch("blitz");
    return { value: "" };
  }
});

var __async$7 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function assert(condition, message) {
  if (!condition)
    throw new Error(message);
}
class AppGenerator extends Generator {
  constructor() {
    super(...arguments);
    this.sourceRoot = { type: "template", path: this.options.template.path };
    this.prettierDisabled = true;
    this.packageInstallSuccess = false;
  }
  filesToIgnore() {
    if (!this.options.useTs) {
      return ["tsconfig.json", "next-env.d.ts", "vitest-config.ts", "package.ts.json", "types.ts"];
    }
    return ["jsconfig.json", "package.js.json", "vitest.config.js"];
  }
  getTemplateValues() {
    return __async$7(this, null, function* () {
      return {
        name: this.options.appName,
        safeNameSlug: this.options.appName.replace(/[^a-zA-Z0-9-_]/g, "-"),
        username: yield username()
      };
    });
  }
  getTargetDirectory() {
    return "";
  }
  preCommit() {
    return __async$7(this, null, function* () {
      this.fs.move(this.destinationPath("gitignore"), this.destinationPath(".gitignore"));
      this.fs.move(this.destinationPath("npmrc"), this.destinationPath(".npmrc"));
      this.fs.move(
        this.destinationPath(this.options.useTs ? "package.ts.json" : "package.js.json"),
        this.destinationPath("package.json")
      );
      const rpcEndpointPath = `src/pages/api/rpc/blitzrpcroute.${this.options.useTs ? "ts" : "js"}`;
      if (this.fs.exists(rpcEndpointPath)) {
        this.fs.move(
          this.destinationPath(rpcEndpointPath),
          this.destinationPath(`src/pages/api/rpc/[[...blitz]].${this.options.useTs ? "ts" : "js"}`)
        );
      }
      if (!this.options.template.skipForms) {
        this.updateForms();
      }
    });
  }
  postWrite() {
    return __async$7(this, null, function* () {
      var _a, _b;
      const { pkgManager } = this;
      let gitInitSuccessful;
      if (!this.options.skipGit) {
        const initResult = spawn.sync("git", ["init"], {
          stdio: "ignore"
        });
        gitInitSuccessful = initResult.status === 0;
        if (!gitInitSuccessful) {
          baseLogger({ displayDateTime: false }).warn("Failed to run git init.");
          baseLogger({ displayDateTime: false }).warn(
            "Find out more about how to install git here: https://git-scm.com/downloads."
          );
        }
      }
      const pkgJsonLocation = join(this.destinationPath(), "package.json");
      const pkg = readJSONSync(pkgJsonLocation);
      console.log("");
      const spinner = log.spinner(log.withBrand("Retrieving the freshest of dependencies")).start();
      const [
        { value: newDependencies, isFallback: dependenciesUsedFallback },
        { value: newDevDependencies, isFallback: devDependenciesUsedFallback },
        { value: blitzDependencyVersion }
      ] = yield Promise.all([
        fetchLatestVersionsFor(pkg.dependencies),
        fetchLatestVersionsFor(pkg.devDependencies),
        getBlitzDependencyVersion()
      ]);
      pkg.dependencies = newDependencies;
      pkg.devDependencies = newDevDependencies;
      pkg.dependencies.blitz = blitzDependencyVersion;
      pkg.dependencies["@blitzjs/next"] = blitzDependencyVersion;
      pkg.dependencies["@blitzjs/rpc"] = blitzDependencyVersion;
      pkg.dependencies["@blitzjs/auth"] = blitzDependencyVersion;
      const fallbackUsed = dependenciesUsedFallback || devDependenciesUsedFallback;
      yield writeJson(pkgJsonLocation, pkg, { spaces: 2 });
      if (!fallbackUsed && !this.options.skipInstall) {
        spinner.succeed();
        yield new Promise((resolve) => {
          var _a2, _b2, _c, _d;
          const logFlag = pkgManager === "yarn" ? "--json" : "--loglevel=error";
          const cp = spawn(pkgManager, ["install", logFlag], {
            stdio: ["inherit", "pipe", "pipe"]
          });
          const getJSON = (data) => {
            try {
              return JSON.parse(data);
            } catch (e) {
              return null;
            }
          };
          const spinners = [];
          if (pkgManager !== "yarn") {
            const spinner2 = log.spinner(log.withBrand("Installing those dependencies (this will take a few minutes)")).start();
            spinners.push(spinner2);
          }
          (_a2 = cp.stdout) == null ? void 0 : _a2.setEncoding("utf8");
          (_b2 = cp.stderr) == null ? void 0 : _b2.setEncoding("utf8");
          (_c = cp.stdout) == null ? void 0 : _c.on("data", (data) => {
            var _a3, _b3, _c2;
            if (pkgManager === "pnpm") {
              if (data.includes("ERR_PNPM_PEER_DEP_ISSUES\u2009 Unmet peer dependencies")) {
                (_a3 = spinners[spinners.length - 1]) == null ? void 0 : _a3.succeed();
              }
            }
            if (pkgManager === "yarn") {
              let json = getJSON(data);
              if (json && json.type === "step") {
                (_b3 = spinners[spinners.length - 1]) == null ? void 0 : _b3.succeed();
                const spinner2 = log.spinner(log.withBrand(json.data.message)).start();
                spinners.push(spinner2);
              }
              if (json && json.type === "success") {
                (_c2 = spinners[spinners.length - 1]) == null ? void 0 : _c2.succeed();
              }
            }
          });
          (_d = cp.stderr) == null ? void 0 : _d.on("data", (data) => {
            var _a3;
            if (pkgManager === "yarn") {
              let json = getJSON(data);
              if (json && json.type === "error") {
                (_a3 = spinners[spinners.length - 1]) == null ? void 0 : _a3.fail();
                console.error(json.data);
              }
            } else {
              if (!data.includes("schema.prisma")) {
                console.error(`
${data}`);
              }
            }
          });
          cp.on("exit", (code) => {
            if (pkgManager !== "yarn" && spinners[spinners.length - 1].isSpinning) {
              if (code !== 0)
                spinners[spinners.length - 1].fail();
              else {
                spinners[spinners.length - 1].succeed();
                this.packageInstallSuccess = true;
              }
            }
            resolve();
          });
        });
        yield (_b = (_a = this.options).onPostInstall) == null ? void 0 : _b.call(_a);
        const runLocalNodeCLI = (command) => {
          const { pkgManager: pkgManager2 } = this;
          if (pkgManager2 === "yarn") {
            return spawn.sync("yarn", ["run", ...command.split(" ")]);
          } else if (pkgManager2 === "pnpm") {
            return spawn.sync("pnpm", command.split(" "));
          } else {
            return spawn.sync("npx", command.split(" "));
          }
        };
        if (this.packageInstallSuccess) {
          const formattingSpinner = log.spinner(log.withBrand("Formatting your code")).start();
          const prettierResult = runLocalNodeCLI("prettier --loglevel silent --write .");
          if (prettierResult.status !== 0) {
            formattingSpinner.fail(
              chalk.yellow.bold(
                "We had an error running Prettier, but don't worry your app will still run fine :)"
              )
            );
          } else {
            formattingSpinner.succeed();
          }
        }
      } else {
        console.log("");
        if (this.options.skipInstall) {
          spinner.succeed();
        } else {
          spinner.fail(
            chalk.red.bold(
              `We had some trouble connecting to the network, so we'll skip installing your dependencies right now. Make sure to run ${`${this.pkgManager} install`} once you're connected again.`
            )
          );
        }
      }
      if (!this.options.skipGit && gitInitSuccessful) {
        this.commitChanges();
      }
    });
  }
  preventFileFromLogging(path) {
    if (path.includes(".env"))
      return false;
    if (path.includes("eslint"))
      return false;
    const filename = path.split("/").pop();
    return path[0] === "." || filename[0] === ".";
  }
  commitChanges() {
    const commitSpinner = log.spinner(log.withBrand("Committing your app")).start();
    const commands = [
      ["git", ["add", "."], { stdio: "ignore" }],
      [
        "git",
        ["commit", "--no-verify", "-m", "Brand new Blitz app!"],
        { stdio: "ignore", timeout: 1e4 }
      ]
    ];
    for (let command of commands) {
      const result = spawn.sync(...command);
      if (result.status !== 0) {
        commitSpinner.fail(
          chalk.red.bold(
            `Failed to run command ${command[0]} with ${command[1].join(" ")} options.`
          )
        );
        return;
      }
    }
    commitSpinner.succeed();
  }
  updateForms() {
    const pkg = this.fs.readJSON(this.destinationPath("package.json"));
    assert(pkg, "couldn't find package.json");
    const ext = this.options.useTs ? "tsx" : "js";
    const type = this.options.form;
    switch (type) {
      case "finalform":
        pkg.dependencies["final-form"] = "4.x";
        pkg.dependencies["react-final-form"] = "6.x";
        break;
      case "hookform":
        pkg.dependencies["react-hook-form"] = "7.x";
        pkg.dependencies["@hookform/resolvers"] = "2.x";
        pkg.dependencies["@hookform/error-message"] = "2.x";
        break;
      case "formik":
        pkg.dependencies["formik"] = "2.x";
        break;
    }
    this.fs.move(
      this.destinationPath(`_forms/${type}/Form.${ext}`),
      this.destinationPath(`src/core/components/Form.${ext}`)
    );
    this.fs.move(
      this.destinationPath(`_forms/${type}/LabeledTextField.${ext}`),
      this.destinationPath(`src/core/components/LabeledTextField.${ext}`)
    );
    this.fs.writeJSON(this.destinationPath("package.json"), pkg);
    this.fs.delete(this.destinationPath("_forms"));
  }
  get pkgManager() {
    if (this.options.pnpm) {
      return "pnpm";
    } else if (this.options.yarn) {
      return "yarn";
    } else {
      return "npm";
    }
  }
}

const checkInputsOrRaise = (inputs) => {
  if (typeof inputs === "string") {
    checkInputOrRaise(inputs);
  } else {
    inputs.forEach((input) => checkInputOrRaise(input));
  }
};
const checkInputOrRaise = (input) => {
  const regex = /^[a-zA-Z0-9-_:=\?[\]\s]+$/;
  if (!regex.test(input)) {
    const firstInvalidCharacter = input.match(/[^a-zA-Z0-9-_:=\?[\]\s]/);
    if (firstInvalidCharacter) {
      log.branded(
        "Blitz Generator Parser Error: " + chalk.red(
          `Input contains invalid character: "${firstInvalidCharacter[0]}" in ${firstInvalidCharacter.input} at position ${firstInvalidCharacter.index}`
        )
      );
    }
    throw new Error(
      "Input should only contain alphanumeric characters, spaces, and the following characters: - _ : = ? [ ]"
    );
  }
};

function plural(input) {
  return pluralize.isPlural(input) ? input : pluralize.plural(input);
}
function singular(input) {
  return pluralize.isSingular(input) ? input : pluralize.singular(input);
}
function capitalize(input) {
  return `${input.slice(0, 1).toUpperCase()}${input.slice(1)}`;
}
function uncapitalize(input) {
  return `${input.slice(0, 1).toLowerCase()}${input.slice(1)}`;
}
const singlePascal = pipe(singular, capitalize);
const singleCamel = pipe(singular, uncapitalize);
const pluralPascal = pipe(plural, capitalize);
const pluralCamel = pipe(plural, uncapitalize);
function camelCaseToKebabCase(transformString) {
  return transformString.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
}

var Relation = /* @__PURE__ */ ((Relation2) => {
  Relation2[Relation2["belongsTo"] = 0] = "belongsTo";
  return Relation2;
})(Relation || {});
function isRelation(maybeRelation) {
  return Object.keys(Relation).includes(maybeRelation);
}
const fallbackIfUndef = (defaultValue, input) => {
  if (input === void 0)
    return defaultValue;
  return input;
};
const defaultValueTest = /=([\w]+)$/;
const builtInGenerators = ["autoincrement", "now", "uuid", "cuid"];
class MissingFieldNameError extends Error {
}
class Field {
  static parse(input, schema) {
    checkInputsOrRaise(input);
    const [_fieldName, _fieldType = "String", _attribute] = input.split(":");
    let attribute = _attribute;
    let fieldName = uncapitalize(_fieldName);
    let fieldType = capitalize(_fieldType);
    const isId = fieldName === "id";
    let isRequired = true;
    let isList = false;
    let isUpdatedAt = false;
    let isUnique = false;
    let defaultValue = void 0;
    let relationFromFields = void 0;
    let relationToFields = void 0;
    let maybeIdField = void 0;
    if (fieldType.includes("?")) {
      fieldType = fieldType.replace("?", "");
      isRequired = false;
    }
    if (fieldType.includes("[]")) {
      fieldType = fieldType.replace("[]", "");
      fieldName = uncapitalize(fieldName);
      isList = true;
    }
    if (fieldType === "Uuid" /* Uuid */) {
      fieldType = "String" /* String */;
      attribute = "default=uuid";
    }
    if (typeof _fieldName === "string" && isRelation(_fieldName)) {
      const relationType = Relation[_fieldName];
      fieldName = uncapitalize(fieldType);
      fieldType = singlePascal(fieldType);
      switch (relationType) {
        case 0 /* belongsTo */:
          const idFieldName = `${fieldName}Id`;
          relationFromFields = [idFieldName];
          relationToFields = ["id"];
          const relationModel = schema == null ? void 0 : schema.list.find(function(component) {
            return component.type === "model" && component.name === fieldType;
          });
          const relationField = relationModel && relationModel.properties.find(function(prop) {
            return prop.type === "field" && prop.name === "id";
          });
          maybeIdField = new Field(idFieldName, {
            type: relationField ? relationField.fieldType : "Int" /* Int */,
            isRequired
          });
          isList = false;
          break;
      }
    }
    if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(fieldName)) {
      throw new Error(
        `[Field.parse]: received unknown special character in field name: ${fieldName}`
      );
    }
    if (/unique/i.test(attribute))
      isUnique = true;
    if (/updatedAt/i.test(attribute))
      isUpdatedAt = true;
    if (/default/i.test(attribute)) {
      if (defaultValueTest.test(attribute)) {
        const [, _defaultValue] = attribute.match(defaultValueTest);
        defaultValue = builtInGenerators.includes(_defaultValue) ? { type: "function", name: _defaultValue, params: [] } : _defaultValue;
      }
    }
    try {
      const parseResult = new Field(fieldName, {
        default: defaultValue,
        isId,
        isList,
        isRequired,
        isUnique,
        isUpdatedAt,
        relationFromFields,
        relationToFields,
        type: fieldType
      });
      return maybeIdField ? [parseResult, maybeIdField] : [parseResult];
    } catch (err) {
      if (err instanceof MissingFieldNameError) {
        throw new Error(
          `Each field in a model must have a name, but you supplied ${input}.

           Try giving the field as a "name:type" pair, such as "description:string".`
        );
      }
      throw err;
    }
  }
  constructor(name, options) {
    if (!name)
      throw new MissingFieldNameError("[PrismaField]: A field name is required");
    if (!options.type) {
      console.warn(`No field type specified for field ${name}, falling back to "String".`);
      options.type = "String" /* String */;
    }
    this.name = name;
    this.isList = fallbackIfUndef(false, options.isList);
    this.isRequired = fallbackIfUndef(true, options.isRequired);
    this.isUnique = fallbackIfUndef(false, options.isUnique);
    this.isId = fallbackIfUndef(false, options.isId);
    this.type = options.type;
    this.default = options.default;
    this.isUpdatedAt = fallbackIfUndef(false, options.isUpdatedAt);
    this.relationFromFields = options.relationFromFields;
    this.relationToFields = options.relationToFields;
    if (!this.isRequired && this.isList) {
      throw new Error("[PrismaField]: a type cannot be both optional and a list");
    }
    if (this.isId && this.default === void 0) {
      throw new Error("[PrismaField]: ID fields must have a default value");
    }
  }
  appendTo(model) {
    if (model.properties.some((prop) => prop.type === "field" && prop.name === this.name))
      return;
    const attributes = [
      this.getId(),
      this.getIsUnique(),
      this.getDefault(),
      this.getIsUpdatedAt(),
      this.getRelation()
    ].filter(Boolean);
    model.properties.push({
      type: "field",
      name: this.name,
      fieldType: this.type,
      optional: !this.isRequired,
      array: this.isList,
      attributes
    });
  }
  getDefault() {
    if (this.default == null)
      return;
    return {
      type: "attribute",
      kind: "field",
      name: "default",
      args: [
        {
          type: "attributeArgument",
          value: typeof this.default === "object" ? `${this.default.name}()` : String(this.default)
        }
      ]
    };
  }
  getId() {
    if (!this.isId)
      return;
    return {
      type: "attribute",
      kind: "field",
      name: "id"
    };
  }
  getIsUnique() {
    if (!this.isUnique)
      return;
    return { type: "attribute", kind: "field", name: "unique" };
  }
  getIsUpdatedAt() {
    if (!this.isUpdatedAt)
      return;
    return { type: "attribute", kind: "field", name: "updatedAt" };
  }
  getRelation() {
    if (this.relationFromFields == null || this.relationToFields == null)
      return;
    return {
      type: "attribute",
      kind: "field",
      name: "relation",
      args: [
        {
          type: "attributeArgument",
          value: {
            type: "keyValue",
            key: "fields",
            value: { type: "array", args: this.relationFromFields }
          }
        },
        {
          type: "attributeArgument",
          value: {
            type: "keyValue",
            key: "references",
            value: { type: "array", args: this.relationToFields }
          }
        }
      ]
    };
  }
}

class Model {
  constructor(name, fields = []) {
    this.name = singlePascal(name);
    this.fields = fields;
  }
  appendTo(schema) {
    const model = this.createModelAst();
    schema.list.push(model);
    return model;
  }
  createModelAst() {
    const properties = [
      this.getIdField(),
      this.getCreatedAtField(),
      this.getUpdatedAtField()
    ].filter(Boolean);
    const model = {
      type: "model",
      name: this.name,
      properties
    };
    for (const field of this.fields)
      field.appendTo(model);
    return model;
  }
  getIdField() {
    if (this.fieldExists("id"))
      return;
    return {
      type: "field",
      name: "id",
      fieldType: "Int",
      attributes: [
        {
          type: "attribute",
          kind: "field",
          name: "id"
        },
        {
          type: "attribute",
          kind: "field",
          name: "default",
          args: [
            {
              type: "attributeArgument",
              value: {
                type: "function",
                name: "autoincrement",
                params: []
              }
            }
          ]
        }
      ]
    };
  }
  getCreatedAtField() {
    if (this.fieldExists("createdAt"))
      return;
    return {
      type: "field",
      name: "createdAt",
      fieldType: "DateTime",
      attributes: [
        {
          type: "attribute",
          kind: "field",
          name: "default",
          args: [
            {
              type: "attributeArgument",
              value: {
                type: "function",
                name: "now",
                params: []
              }
            }
          ]
        }
      ]
    };
  }
  getUpdatedAtField() {
    if (this.fieldExists("updatedAt"))
      return;
    return {
      type: "field",
      name: "updatedAt",
      fieldType: "DateTime",
      attributes: [
        {
          type: "attribute",
          kind: "field",
          name: "updatedAt"
        }
      ]
    };
  }
  fieldExists(name) {
    return this.fields.some((field) => field.name === name);
  }
  toString() {
    return ast.printSchema({
      type: "schema",
      list: [this.createModelAst()]
    });
  }
}

const getTemplateRoot = (templateDir, fallback) => {
  if (!templateDir) {
    return fallback;
  }
  const templatePath = path.join(templateDir, fallback.path);
  if (!fs$1.existsSync(templatePath)) {
    console.info(
      `Template path "${templatePath}" does not exist. Falling back to the default template.`
    );
    return fallback;
  }
  return { path: templatePath, type: "absolute" };
};

var __async$6 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class ModelGenerator extends Generator {
  constructor(options) {
    super(options);
    this.unsafe_disableConflictChecker = true;
    this.sourceRoot = getTemplateRoot(options.templateDir, { type: "absolute", path: "" });
  }
  getTemplateValues() {
    return __async$6(this, null, function* () {
    });
  }
  getTargetDirectory() {
    return "";
  }
  prismaMigratePrompt() {
    return __async$6(this, null, function* () {
      const response = yield this.enquirer.prompt({
        name: "migrate",
        type: "confirm",
        message: "Run 'prisma migrate dev' to update your database?",
        initial: "y"
      });
      return response.migrate === true;
    });
  }
  write() {
    return __async$6(this, null, function* () {
      var _a;
      const pkgJson = this.fs.readJSON("package.json", {});
      const rawSchemaPath = ((_a = pkgJson == null ? void 0 : pkgJson.prisma) == null ? void 0 : _a.schema) || "db/schema.prisma";
      const schemaPath = path__default.resolve(rawSchemaPath);
      if (!this.fs.exists(schemaPath)) {
        throw new Error("Prisma schema file was not found");
      }
      let schema;
      try {
        schema = ast.getSchema(this.fs.read(schemaPath));
      } catch (err) {
        console.error(`Failed to parse ${rawSchemaPath} file`);
        throw err;
      }
      const { modelName, extraArgs, dryRun } = this.options;
      let updatedOrCreated = "created";
      const splitInputCommans = (input) => {
        var _a2, _b;
        const inputs = input.length === 1 && ((_a2 = input[0]) == null ? void 0 : _a2.includes(" ")) ? (_b = input[0]) == null ? void 0 : _b.split(" ") : input;
        checkInputsOrRaise(inputs);
        return inputs;
      };
      let fields = splitInputCommans(extraArgs).flatMap((input) => Field.parse(input, schema));
      const modelDefinition = new Model(modelName, fields);
      let model;
      if (!dryRun) {
        model = schema.list.find(function(component) {
          return component.type === "model" && component.name === modelDefinition.name;
        });
        try {
          if (model) {
            for (const field of fields)
              field.appendTo(model);
            this.fs.write(schemaPath, ast.printSchema(schema));
            updatedOrCreated = "updated";
          } else {
            model = modelDefinition.appendTo(schema);
            this.fs.write(schemaPath, ast.printSchema(schema));
          }
        } catch (err) {
          console.error(`Failed to apply changes to model '${modelDefinition.name}'`);
          throw err;
        }
      }
      if (model) {
        console.log("\n");
        console.log(
          `Model '${modelDefinition.name}'${dryRun ? "" : ` ${updatedOrCreated} in schema.prisma`}:
`
        );
        ast.printSchema({ type: "schema", list: [model] }).split("\n").map(log.progress);
        console.log("\n");
      }
    });
  }
  postWrite() {
    return __async$6(this, null, function* () {
      const shouldMigrate = yield this.prismaMigratePrompt();
      if (shouldMigrate) {
        yield new Promise((res, rej) => {
          const prismaBin = which(process.cwd()).sync("prisma");
          const child = spawn$1(prismaBin, ["migrate", "dev"], { stdio: "inherit" });
          child.on("exit", (code) => code === 0 ? res() : rej());
        });
      }
    });
  }
}
ModelGenerator.subdirectory = "../..";

var __async$5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class MutationsGenerator extends Generator {
  constructor(options) {
    super(options);
    this.sourceRoot = getTemplateRoot(options.templateDir, { type: "template", path: "mutations" });
  }
  getId(input = "") {
    if (!input)
      return input;
    return `${input}Id`;
  }
  getParam(input = "") {
    if (!input)
      return input;
    return `[${input}]`;
  }
  getTemplateValues() {
    return __async$5(this, null, function* () {
      return {
        parentModelId: this.getId(this.options.parentModel),
        parentModelParam: this.getParam(this.getId(this.options.parentModel)),
        parentModel: this.options.parentModel,
        parentModels: this.options.parentModels,
        ParentModel: this.options.ParentModel,
        ParentModels: this.options.ParentModels,
        modelId: this.getId(this.options.modelName),
        modelIdParam: this.getParam(this.getId(this.options.modelName)),
        modelName: this.options.modelName,
        modelNames: this.options.modelNames,
        ModelName: this.options.ModelName,
        ModelNames: this.options.ModelNames
      };
    });
  }
  getTargetDirectory() {
    const context = this.options.context ? `${camelCaseToKebabCase(this.options.context)}/` : "";
    const kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    return `src/${context}${kebabCaseModelName}/mutations`;
  }
}
MutationsGenerator.subdirectory = "mutations";

var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class MutationGenerator extends Generator {
  constructor(options) {
    super(options);
    this.sourceRoot = getTemplateRoot(options.templateDir, { type: "template", path: "mutation" });
  }
  getTemplateValues() {
    return __async$4(this, null, function* () {
      return {
        name: this.options.name,
        Name: this.options.Name
      };
    });
  }
  getTargetDirectory() {
    const context = this.options.context ? `${camelCaseToKebabCase(this.options.context)}` : "";
    return `src/${context}/mutations`;
  }
}
MutationGenerator.subdirectory = "mutation";

var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class PageGenerator extends Generator {
  constructor(options) {
    super(options);
    this.sourceRoot = getTemplateRoot(options.templateDir, { type: "template", path: "page" });
  }
  getId(input = "") {
    if (!input)
      return input;
    return `${input}Id`;
  }
  getParam(input = "") {
    if (!input)
      return input;
    return `[${input}]`;
  }
  getTemplateValues() {
    return __async$3(this, null, function* () {
      return {
        parentModelId: this.getId(this.options.parentModel),
        parentModelParam: this.getParam(this.getId(this.options.parentModel)),
        parentModel: this.options.parentModel,
        parentModels: this.options.parentModels,
        ParentModel: this.options.ParentModel,
        ParentModels: this.options.ParentModels,
        modelId: this.getId(this.options.modelName),
        modelIdParam: this.getParam(this.getId(this.options.modelName)),
        modelName: this.options.modelName,
        modelNames: this.options.modelNames,
        ModelName: this.options.ModelName,
        ModelNames: this.options.ModelNames,
        modelNamesPath: this.getModelNamesPath()
      };
    });
  }
  getModelNamesPath() {
    const kebabCaseContext = this.options.context ? `${camelCaseToKebabCase(this.options.context)}/` : "";
    const kebabCaseModelNames = camelCaseToKebabCase(this.options.modelNames);
    return kebabCaseContext + kebabCaseModelNames;
  }
  getTargetDirectory() {
    const kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    const parent = this.options.parentModels ? `${this.options.parentModels}/__parentModelParam__/` : "";
    return `src/pages/${parent}${kebabCaseModelName}`;
  }
  postWrite() {
    return __async$3(this, null, function* () {
      yield new Promise((res, rej) => {
        const blitzBin = which(process.cwd()).sync("blitz");
        const child = spawn$1(blitzBin, ["codegen"], { stdio: "inherit" });
        child.on("exit", (code) => code === 0 ? res() : rej());
      });
    });
  }
}
PageGenerator.subdirectory = "../../..";

var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class QueriesGenerator extends Generator {
  constructor(options) {
    super(options);
    this.sourceRoot = getTemplateRoot(options.templateDir, { type: "template", path: "queries" });
  }
  getId(input = "") {
    if (!input)
      return input;
    return `${input}Id`;
  }
  getParam(input = "") {
    if (!input)
      return input;
    return `[${input}]`;
  }
  getTemplateValues() {
    return __async$2(this, null, function* () {
      return {
        parentModelId: this.getId(this.options.parentModel),
        parentModelParam: this.getParam(this.getId(this.options.parentModel)),
        parentModel: this.options.parentModel,
        parentModels: this.options.parentModels,
        ParentModel: this.options.ParentModel,
        ParentModels: this.options.ParentModels,
        modelId: this.getId(this.options.modelName),
        modelIdParam: this.getParam(this.getId(this.options.modelName)),
        modelName: this.options.modelName,
        modelNames: this.options.modelNames,
        ModelName: this.options.ModelName,
        ModelNames: this.options.ModelNames
      };
    });
  }
  getTargetDirectory() {
    const context = this.options.context ? `${camelCaseToKebabCase(this.options.context)}/` : "";
    const kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    return `src/${context}${kebabCaseModelName}/queries`;
  }
}
QueriesGenerator.subdirectory = "queries";

var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class QueryGenerator extends Generator {
  constructor(options) {
    super(options);
    this.sourceRoot = getTemplateRoot(options.templateDir, { type: "template", path: "query" });
  }
  getTemplateValues() {
    return __async$1(this, null, function* () {
      return {
        name: this.options.name,
        Name: this.options.Name
      };
    });
  }
  getTargetDirectory() {
    const context = this.options.context ? `${camelCaseToKebabCase(this.options.context)}` : "";
    return `src/${context}/queries`;
  }
}
QueryGenerator.subdirectory = "query";

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
class FormGenerator extends Generator {
  constructor(options) {
    super(options);
    this.sourceRoot = getTemplateRoot(options.templateDir, { type: "template", path: "form" });
  }
  getId(input = "") {
    if (!input)
      return input;
    return `${input}Id`;
  }
  getParam(input = "") {
    if (!input)
      return input;
    return `[${input}]`;
  }
  getTemplateValues() {
    return __async(this, null, function* () {
      return {
        parentModelId: this.getId(this.options.parentModel),
        parentModelParam: this.getParam(this.getId(this.options.parentModel)),
        parentModel: this.options.parentModel,
        parentModels: this.options.parentModels,
        ParentModel: this.options.ParentModel,
        ParentModels: this.options.ParentModels,
        modelId: this.getId(this.options.modelName),
        modelIdParam: this.getParam(this.getId(this.options.modelName)),
        modelName: this.options.modelName,
        modelNames: this.options.modelNames,
        ModelName: this.options.ModelName,
        ModelNames: this.options.ModelNames
      };
    });
  }
  getTargetDirectory() {
    const context = this.options.context ? `${camelCaseToKebabCase(this.options.context)}/` : "";
    const kebabCaseModelName = camelCaseToKebabCase(this.options.modelNames);
    return `src/${context}${kebabCaseModelName}/components`;
  }
}
FormGenerator.subdirectory = "queries";

export { AppGenerator, ConflictChecker, FormGenerator, Generator, ModelGenerator, MutationGenerator, MutationsGenerator, PageGenerator, QueriesGenerator, QueryGenerator, capitalize, customTemplatesBlitzConfig, customTsParser, fetchAllVersions, fetchDistTags, fetchLatestDistVersion, getBlitzDependencyVersion, getConfigSrcPath, getLatestVersion, getProjectRootSync, pluralCamel, pluralPascal, singleCamel, singlePascal, uncapitalize };
